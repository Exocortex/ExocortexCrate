// alembicPlugin
// Initial code generated by Softimage SDK Wizard
// Executed Fri Aug 19 09:14:49 UTC+0200 2011 by helge
//
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the
// Plugin Manager.
#include "stdafx.h"

#include "arnoldHelpers.h"

using namespace XSI;
using namespace MATH;

#include "AlembicLicensing.h"

#include "AlembicCurves.h"
#include "AlembicPoints.h"
#include "AlembicWriteJob.h"
#include "CommonAbcCache.h"
#include "CommonImport.h"
#include "CommonMeshUtilities.h"
#include "CommonProfiler.h"
#include "CommonUtilities.h"
#include "sceneGraph.h"

CString getTimeControlExpression(CString timeControlName)
{
  return timeControlName + L".current * " + timeControlName + L".factor + " +
         timeControlName + L".offset + " + timeControlName +
         L".frameOffset / Fr";
}

ESS_CALLBACK_START(alembic_import_Init, CRef&)
Context ctxt(in_ctxt);
Command oCmd;
oCmd = ctxt.GetSource();
oCmd.PutDescription(L"");
oCmd.EnableReturnValue(true);

ArgumentArray oArgs;
oArgs = oCmd.GetArguments();
oArgs.Add(L"filename");
oArgs.Add(L"normals");
oArgs.Add(L"uvs");
oArgs.Add(L"clusters");
oArgs.Add(L"visibility");
oArgs.Add(L"standins");
oArgs.Add(L"bboxes");
oArgs.Add(L"attach");
oArgs.Add(L"failOnUnsupported");
oArgs.Add(L"identifiers");
return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_import_jobs_Init, CRef&)

Context ctxt(in_ctxt);
Command oCmd;
oCmd = ctxt.GetSource();
oCmd.PutDescription(L"");
oCmd.EnableReturnValue(true);

ArgumentArray oArgs;
oArgs = oCmd.GetArguments();
oArgs.Add(L"importjobs");
return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_create_item_Init, CRef&)
Context ctxt(in_ctxt);
Command oCmd;
oCmd = ctxt.GetSource();
oCmd.PutDescription(L"");
oCmd.EnableReturnValue(true);

ArgumentArray oArgs;
oArgs = oCmd.GetArguments();
oArgs.Add(L"type");
oArgs.Add(L"target");
oArgs.Add(L"file");
oArgs.Add(L"identifier");
oArgs.Add(L"reattach");
oArgs.Add(L"timecontrolprop");
oArgs.Add(L"facesets");
oArgs.Add(L"normals");
oArgs.Add(L"uvs");
oArgs.Add(L"bindpose");
return CStatus::OK;
ESS_CALLBACK_END

enum alembicItemType {
  alembicItemType_xform,
  alembicItemType_camera,
  alembicItemType_polymesh_topo,
  alembicItemType_bbox,
  alembicItemType_polymesh,
  alembicItemType_crvlist_topo,
  alembicItemType_crvlist,
  alembicItemType_curves,
  alembicItemType_points,
  alembicItemType_metadata,
  alembicItemType_timecontrol,
  alembicItemType_visibility,
  alembicItemType_geomapprox,
  alembicItemType_standin,
  alembicItemType_nurbs,
  alembicItemType_none
};

std::map<std::string, alembicItemType> gItemTypeMap;

CStatus alembic_create_item_Invoke(const CString& type,
                                   const CRef& importRootNode,
                                   const CRef& target, const CString& file,
                                   const CString& identifier,
                                   bool attachToExisting,
                                   const CValueArray& args, CValue& returnVal)
{
  ESS_PROFILE_SCOPE("alembic_create_item_Invoke");

  // fill the map in case it is empty
  if (gItemTypeMap.size() == 0) {
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_xform", alembicItemType_xform));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_camera", alembicItemType_camera));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_polymesh_topo", alembicItemType_polymesh_topo));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_bbox", alembicItemType_bbox));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_polymesh", alembicItemType_polymesh));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_crvlist_topo", alembicItemType_crvlist_topo));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_crvlist", alembicItemType_crvlist));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_curves", alembicItemType_curves));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_points", alembicItemType_points));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_metadata", alembicItemType_metadata));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_timecontrol", alembicItemType_timecontrol));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_visibility", alembicItemType_visibility));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_geomapprox", alembicItemType_geomapprox));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_standin", alembicItemType_standin));
    gItemTypeMap.insert(std::pair<std::string, alembicItemType>(
        "alembic_nurbs", alembicItemType_nurbs));
  }

  // query the item type from the map
  CString realType(type);
  realType.Lower();
  std::map<std::string, alembicItemType>::iterator it =
      gItemTypeMap.find(realType.GetAsciiString());
  alembicItemType itemType = alembicItemType_none;
  if (it != gItemTypeMap.end()) {
    itemType = it->second;
  }

  // cast into the standard types
  X3DObject x3d(target);
  Primitive prim(target);

  bool bMultifile = args[5];

  // now let's find the real target for this
  CRef realTarget;
  {
    ESS_PROFILE_SCOPE("alembic_create_item_Invoke find_real_target");
    switch (itemType) {
      case alembicItemType_xform: {
        if (x3d.IsValid()) {
          realTarget = x3d.GetKinematics().GetLocal().GetRef();
        }
        else {
          KinematicState kine(target);
          if (kine.IsValid()) {
            realTarget = target;
          }
          else {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '" +
                                         target.GetAsText() + L"' for " + type +
                                         L".",
                                     siErrorMsg);
            return CStatus::InvalidArgument;
          }
        }
        break;
      }
      case alembicItemType_visibility:
      case alembicItemType_geomapprox: {
        if (x3d.IsValid()) {
          Property visProp;
          if (itemType == alembicItemType_visibility) {
            x3d.GetPropertyFromName(L"Visibility", visProp);
          }
          else {
            x3d.GetPropertyFromName(L"GeomApprox", visProp);
          }
          realTarget = visProp.GetRef();
        }
        else {
          Application().LogMessage(L"[ExocortexAlembic] Invalid target '" +
                                       target.GetAsText() + L"' for " + type +
                                       L".",
                                   siErrorMsg);
          return CStatus::InvalidArgument;
        }
        break;
      }
      case alembicItemType_camera: {
        if (x3d.IsValid()) {
          realTarget = x3d.GetActivePrimitive().GetRef();
        }
        else if (prim.IsValid()) {
          realTarget = prim.GetRef();
        }
        else {
          Application().LogMessage(L"[ExocortexAlembic] Invalid target '" +
                                       target.GetAsText() + L"' for " + type +
                                       L".",
                                   siErrorMsg);
          return CStatus::InvalidArgument;
        }
        if (!Primitive(realTarget).GetType().IsEqualNoCase(L"camera")) {
          Application().LogMessage(L"[ExocortexAlembic] Invalid target '" +
                                       target.GetAsText() + L"' for " + type +
                                       L".",
                                   siErrorMsg);
          return CStatus::InvalidArgument;
        }
        break;
      }
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_curves:
      case alembicItemType_points:
      case alembicItemType_nurbs: {
        if (x3d.IsValid()) {
          realTarget = x3d.GetActivePrimitive().GetRef();
        }
        else if (prim.IsValid()) {
          realTarget = prim.GetRef();
        }
        else {
          Application().LogMessage(L"[ExocortexAlembic] Invalid target '" +
                                       target.GetAsText() + L"' for " + type +
                                       L".",
                                   siErrorMsg);
          return CStatus::InvalidArgument;
        }
        // now check the type as well
        if (itemType == alembicItemType_polymesh_topo ||
            itemType == alembicItemType_polymesh) {
          if (!Primitive(realTarget).GetType().IsEqualNoCase(L"polymsh")) {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '" +
                                         target.GetAsText() + L"' for " + type +
                                         L".",
                                     siErrorMsg);
            return CStatus::InvalidArgument;
          }
        }
        else if (itemType == alembicItemType_crvlist_topo ||
                 itemType == alembicItemType_crvlist) {
          CString type = Primitive(realTarget).GetType();
          if (!Primitive(realTarget).GetType().IsEqualNoCase(L"crvlist") &&
              !Primitive(realTarget).GetType().IsEqualNoCase(L"pointcloud") &&
              !Primitive(realTarget).GetType().IsEqualNoCase(L"hair")) {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '" +
                                         target.GetAsText() + L"' for " + type +
                                         L".",
                                     siErrorMsg);
            return CStatus::InvalidArgument;
          }
        }
        else if (itemType == alembicItemType_points ||
                 itemType == alembicItemType_curves) {
          if (!Primitive(realTarget).GetType().IsEqualNoCase(L"pointcloud")) {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '" +
                                         target.GetAsText() + L"' for " + type +
                                         L".",
                                     siErrorMsg);
            return CStatus::InvalidArgument;
          }
        }
        else if (itemType == alembicItemType_nurbs) {
          if (!Primitive(realTarget).GetType().IsEqualNoCase(L"surfmsh")) {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '" +
                                         target.GetAsText() + L"' for " + type +
                                         L".",
                                     siErrorMsg);
            return CStatus::InvalidArgument;
          }
        }
        break;
      }
      case alembicItemType_metadata:
      case alembicItemType_timecontrol: {
        if (x3d.IsValid()) {
          realTarget = x3d.GetRef();
        }
        else {
          Application().LogMessage(L"[ExocortexAlembic] Invalid target '" +
                                       target.GetAsText() + L"' for " + type +
                                       L".",
                                   siErrorMsg);
          return CStatus::InvalidArgument;
        }
        break;
      }
      case alembicItemType_standin: {
        CustomOperator alembicOp(target);
        ICETree alembicTree(target);
        if (!alembicOp.IsValid() && !alembicTree.IsValid()) {
          Application().LogMessage(L"[ExocortexAlembic] Invalid target '" +
                                       target.GetAsText() + L"' for " + type +
                                       L".",
                                   siErrorMsg);
          return CStatus::InvalidArgument;
        }
        if (!alembicOp.GetType().GetSubString(0, 8).IsEqualNoCase(
                L"alembic_") &&
            !alembicTree.GetName().GetSubString(0, 4).IsEqualNoCase(L"abc_")) {
          Application().LogMessage(L"[ExocortexAlembic] Invalid target '" +
                                       target.GetAsText() + L"' for " + type +
                                       L".",
                                   siErrorMsg);
          return CStatus::InvalidArgument;
        }
        if (alembicOp.IsValid()) {
          realTarget = alembicOp.GetRef();
        }
        else {
          // loop for the first custom node
          CRefArray compounds = alembicTree.GetCompoundNodes();
          for (LONG j = 0; j < compounds.GetCount(); j++) {
            ICECompoundNode compound(compounds[j]);
            CRefArray nodes = compound.GetNodes();
            for (LONG k = 0; k < nodes.GetCount(); k++) {
              CString nodeType = ICENode(nodes[k]).GetType();
              if (nodeType.GetSubString(0, 8).IsEqualNoCase(L"alembic_")) {
                realTarget = nodes[k];
                break;
              }
            }

            if (realTarget.IsValid()) {
              break;
            }
          }

          if (!realTarget.IsValid()) {
            Application().LogMessage(
                L"[ExocortexAlembic] Could not find custom abc node on icetree "
                L"'" +
                    target.GetAsText() + L".",
                siErrorMsg);
            return CStatus::InvalidArgument;
          }
        }
        break;
      }
      default: {
        Application().LogMessage(
            L"[ExocortexAlembic] Unknown item type '" + type + L"'.",
            siErrorMsg);
        return CStatus::InvalidArgument;
      }
    }
  }

  // now validate the identifier if necessary
  Abc::IObject abcObject;
  AbcObjectCache* pObjectCache = NULL;
  bool isAnimated = false;
  {
    ESS_PROFILE_SCOPE("alembic_create_item_Invoke validate_the_identifier");
    switch (itemType) {
      case alembicItemType_xform:
      case alembicItemType_camera:
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_curves:
      case alembicItemType_metadata:
      case alembicItemType_points:
      case alembicItemType_geomapprox:
      case alembicItemType_nurbs: {
        pObjectCache =
            getObjectCacheFromArchive(std::string(file.GetAsciiString()),
                                      std::string(identifier.GetAsciiString()));
        if (pObjectCache == NULL || !pObjectCache->obj.valid()) {
          EC_LOG_ERROR("[ExocortexAlembic] Identifier '"
                       << identifier.GetAsciiString()
                       << "' is not valid for given filename: "
                       << file.GetAsciiString());
          return CStatus::InvalidArgument;
        }
        abcObject = pObjectCache->obj;
        isAnimated = (itemType == alembicItemType_bbox) ||
                     (!pObjectCache->isConstant &&
                      itemType != alembicItemType_geomapprox) ||
                     itemType == alembicItemType_points || bMultifile;
        break;
      }
      case alembicItemType_visibility: {
        pObjectCache =
            getObjectCacheFromArchive(std::string(file.GetAsciiString()),
                                      std::string(identifier.GetAsciiString()));
        if (pObjectCache == NULL || !pObjectCache->obj.valid()) {
          EC_LOG_ERROR("[ExocortexAlembic] Identifier '"
                       << identifier.GetAsciiString()
                       << "' is not valid for given filename: "
                       << file.GetAsciiString());
          return CStatus::InvalidArgument;
        }
        abcObject = pObjectCache->obj;
        AbcG::IVisibilityProperty visibilityProperty =
            getAbcVisibilityProperty(abcObject);
        if (!visibilityProperty.valid()) {
          return CStatus::InvalidArgument;
        }
        isAnimated = visibilityProperty.getNumSamples() > 1;
        break;
      }
      case alembicItemType_standin:
      default:
        break;
    }
  }

  // check if we have a timecontrol in the args
  CustomProperty timeControlProp;
  CRef timeControlRef;
  if (args.GetCount() > 0) {
    timeControlRef = args[0];
  }
  timeControlProp = timeControlRef;
  CValue setExprReturn;
  CValueArray setExprArgs(2);
  CString expressionString;
  if (timeControlProp.IsValid()) {
    setExprArgs[1] = getTimeControlExpression(timeControlProp.GetFullName());
    expressionString = getTimeControlExpression(timeControlProp.GetFullName());
  }

  // TODO: enable operator creation if "attach to existing" and user option are
  // enabled

  bool operatorCreationForExistingOperators = args[6];
  bool bEnableOperatorCreation = true;
  // if operator creation is disabled for this import, and we are doing a node
  // update (attachToExisting is true for this node),
  //   then disable operator creation for this node
  if (!operatorCreationForExistingOperators) {
    bEnableOperatorCreation = !attachToExisting;
  }

  {
    ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator");
    // now create an operator...?
    switch (itemType) {
      case alembicItemType_xform:
      case alembicItemType_visibility:
      case alembicItemType_geomapprox:
      case alembicItemType_camera:
      case alembicItemType_polymesh_topo:  // in this case, a normals operator
      // and multiple UV operator may be
      // created. Also, clusters may be
      // created.
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_nurbs: {
        ESS_PROFILE_SCOPE(
            "alembic_create_item_Invoke create_the_operator "
            "alembicItemType_xxx");
        // for visibility, let's see if we should create an operator
        if (itemType == alembicItemType_visibility) {
          ESS_PROFILE_SCOPE(
              "alembic_create_item_Invoke create_the_operator visibility");
          bool importVis = args[4];
          if (!isAnimated && !importVis) {
            // this means skip the creation of the operator
            AbcG::IVisibilityProperty visibilityProperty =
                getAbcVisibilityProperty(abcObject);
            if (visibilityProperty.valid()) {
              int rawVisibilityValue = visibilityProperty.getValue(size_t(0));
              AbcG::ObjectVisibility visibilityValue =
                  AbcG::ObjectVisibility(rawVisibilityValue);

              Property prop(realTarget);
              switch (visibilityValue) {
                case AbcG::kVisibilityVisible: {
                  prop.PutParameterValue(L"viewvis", true);
                  prop.PutParameterValue(L"rendvis", true);
                  break;
                }
                case AbcG::kVisibilityHidden: {
                  prop.PutParameterValue(L"viewvis", false);
                  prop.PutParameterValue(L"rendvis", false);
                  break;
                }
                default: {
                  break;
                }
              }
              break;
            }
          }
        }
        else if (itemType == alembicItemType_xform) {
          const bool importTransforms = args[7];
          if (!isAnimated && !importTransforms) {
            ESS_PROFILE_SCOPE("alembic_create_itme_Invoke importConstantXform");

            CustomOperator op;
            if (attachToExisting) {
              CRef opRef;
              opRef.Set(realTarget.GetAsText() + L"." + realType);
              op = opRef;
            }

            if (!op.IsValid())  // if an operator already exists
                                // (attachToExisting), then update the operator
                                // instead
            {
              KinematicState kineState(realTarget);

              pObjectCache->getXform();
              Abc::M44d matrix = pObjectCache->getXformMatrix(0);

              CMatrix4 xsiMatrix;
              xsiMatrix.Set(matrix.getValue()[0], matrix.getValue()[1],
                            matrix.getValue()[2], matrix.getValue()[3],
                            matrix.getValue()[4], matrix.getValue()[5],
                            matrix.getValue()[6], matrix.getValue()[7],
                            matrix.getValue()[8], matrix.getValue()[9],
                            matrix.getValue()[10], matrix.getValue()[11],
                            matrix.getValue()[12], matrix.getValue()[13],
                            matrix.getValue()[14], matrix.getValue()[15]);

              CTransformation xsiTransform;
              xsiTransform.SetMatrix4(xsiMatrix);

              kineState.PutTransform(xsiTransform);

              break;
            }
          }
        }

        // for xform, disable softimage scaling
        if (itemType == alembicItemType_xform) {
          KinematicState(realTarget).PutParameterValue(L"siscaling", false);
        }

        CustomOperator op;
        if (attachToExisting) {
          CRef opRef;
          opRef.Set(realTarget.GetAsText() + L"." + realType);
          op = opRef;
        }

        if (!op.IsValid() && bEnableOperatorCreation) {
          {
            ESS_PROFILE_SCOPE(
                "alembic_create_item_Invoke create_the_operator CreateObject");
            op = Application().GetFactory().CreateObject(realType);
          }
          {
            ESS_PROFILE_SCOPE(
                "alembic_create_item_Invoke create_the_operator AddPorts");
            op.AddOutputPort(realTarget);
            op.AddInputPort(realTarget);
          }

          // experimental operator creation code. It doesn't seem faster so
          // far...
          //{
          //   ESS_PROFILE_SCOPE("alembic_create_item_Invoke AddCustomOp");
          //  CRefArray inputs(1);
          //  inputs[0] = realTarget;
          //  if(itemType == alembicItemType_xform){
          //     KinematicState targetObject(realTarget);
          //     op = targetObject.AddCustomOp( realType, inputs );
          //  }
          //  else{
          //     ProjectItem targetObject(realTarget);
          //     op = targetObject.AddCustomOp( realType, inputs );
          //  }
          //}

          siConstructionMode consMode = siConstructionModeModeling;
          if (itemType != alembicItemType_crvlist_topo &&
              itemType != alembicItemType_polymesh_topo) {
            consMode = siConstructionModeAnimation;
          }
          {
            ESS_PROFILE_SCOPE(
                "alembic_create_item_Invoke create_the_operator Connect");
            op.Connect(consMode);
          }
        }

        if (op.IsValid()) {  // connect up the operator parameters

          op.PutParameterValue(L"path", file);
          op.PutParameterValue(L"identifier", identifier);
          if (bMultifile) {
            op.PutParameterValue(L"multifile", true);
          }

          // if we are not a topo op, let's connect to the timecontrol
          bool receivesExpression = isAnimated;

          if (!bMultifile) {
            ESS_PROFILE_SCOPE(
                "alembic_create_item_Invoke create_the_operator dynamic topo "
                "check");
            if (itemType == alembicItemType_crvlist_topo) {
              receivesExpression = false;
            }
            else if (itemType == alembicItemType_polymesh_topo) {
              // check if the compound has more than one sample on its
              // facecounts
              Abc::ICompoundProperty abcCompound =
                  getCompoundFromObject(abcObject);
              Abc::IInt32ArrayProperty faceCountProp =
                  Abc::IInt32ArrayProperty(abcCompound, ".faceCounts");
              if (faceCountProp.valid()) {
                receivesExpression = !faceCountProp.isConstant();
              }

              if (!receivesExpression)  // still false, check .faceIndices just
                                        // in case and reuse faceCountProp
                                        // variable!
              {
                faceCountProp =
                    Abc::IInt32ArrayProperty(abcCompound, ".faceIndices");
                if (faceCountProp.valid()) {
                  receivesExpression = !faceCountProp.isConstant();
                }
                else {
                  receivesExpression = false;
                }
              }
            }
          }

          if (receivesExpression) {
            ESS_PROFILE_SCOPE(
                "alembic_create_item_Invoke create_the_operator "
                "receivesExpression");

            // check if we have a timecontrol in the args
            if (timeControlProp.IsValid()) {
              // setExprArgs[0] = op.GetFullName()+L".time";
              op.GetParameter("time").AddExpression(expressionString);
              // Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
            }
          }
        }

        // store the return value
        returnVal = op.GetRef();

        // if we are a polygon mesh topo op, oh dear
        if (itemType == alembicItemType_polymesh_topo && args.GetCount() > 3) {
          ESS_PROFILE_SCOPE(
              "alembic_create_item_Invoke create_the_operator polymesh_topo");

          bool importClusters = args[1];
          bool importNormals = args[2];
          bool importUvs = args[3];

          AbcG::IPolyMesh abcMesh;
          AbcG::ISubD abcSubD;
          if (AbcG::IPolyMesh::matches(abcObject.getMetaData())) {
            abcMesh = AbcG::IPolyMesh(abcObject, Abc::kWrapExisting);
          }
          else {
            abcSubD = AbcG::ISubD(abcObject, Abc::kWrapExisting);
          }
          if (!abcMesh.valid() && !abcSubD.valid()) {
            return CStatus::OK;
          }

          PolygonMesh meshGeo = Primitive(realTarget).GetGeometry();
          // for our "apply" mode, I feel no changes our necessary here. It is
          // hard to know what user intended.
          // Let them handle it via the option that already exists.
          if (importClusters) {
            ESS_PROFILE_SCOPE(
                "alembic_create_item_Invoke create_the_operator polymesh_topo "
                "importClusters");
            std::vector<std::string> faceSetNames;
            if (abcMesh.valid()) {
              abcMesh.getSchema().getFaceSetNames(faceSetNames);
            }
            else {
              abcSubD.getSchema().getFaceSetNames(faceSetNames);
            }
            for (size_t j = 0; j < faceSetNames.size(); j++) {
              if (attachToExisting) {
                if (meshGeo.GetClusters()
                        .GetItem(CString(faceSetNames[j].c_str()))
                        .IsValid()) {  // only create clusters that do not exist
                  continue;
                }
              }
              AbcG::IFaceSetSchema faceSet;
              if (abcMesh.valid())
                faceSet =
                    abcMesh.getSchema().getFaceSet(faceSetNames[j]).getSchema();
              else
                faceSet =
                    abcSubD.getSchema().getFaceSet(faceSetNames[j]).getSchema();
              AbcG::IFaceSetSchema::Sample faceSetSample = faceSet.getValue();
              Abc::Int32ArraySamplePtr faces = faceSetSample.getFaces();
              CLongArray elements((LONG)faces->size());
              for (size_t k = 0; k < faces->size(); k++) {
                elements[(LONG)k] = (LONG)faces->get()[k];
              }
              Cluster cluster;
              meshGeo.AddCluster(L"poly", CString(faceSetNames[j].c_str()),
                                 elements, cluster);
            }
          }

          if (importNormals && abcMesh.valid()) {
            ESS_PROFILE_SCOPE(
                "alembic_create_item_Invoke create_the_operator polymesh_topo "
                "importNormals");
            AbcG::IN3fGeomParam meshNormalsParam =
                abcMesh.getSchema().getNormalsParam();
            if (meshNormalsParam.valid()) {
              Abc::N3fArraySamplePtr meshNormals =
                  meshNormalsParam.getExpandedValue(0).getVals();

              CRef clusterPropRef;
              if (attachToExisting)
                clusterPropRef.Set(
                    realTarget.GetAsText() +
                    L".cls.User_Normal_Cluster.User_Normal_Property");
              if (!clusterPropRef.IsValid()) {
                // create user normals
                CValue createUserNormalReturnVal;
                CValueArray createUserNormalArgs(1);
                createUserNormalArgs[0] =
                    Primitive(realTarget).GetParent3DObject().GetFullName();
                Application().ExecuteCommand(L"CreateUserNormals",
                                             createUserNormalArgs,
                                             createUserNormalReturnVal);
              }
              ClusterProperty userNormalProp;
              CRefArray clusters = meshGeo.GetClusters();
              for (LONG j = 0; j < clusters.GetCount(); j++) {
                Cluster cluster(clusters[j]);
                if (!cluster.GetType().IsEqualNoCase(L"sample")) {
                  continue;
                }
                CRefArray props(cluster.GetLocalProperties());
                for (LONG k = 0; k < props.GetCount(); k++) {
                  ClusterProperty prop(props[k]);
                  if (prop.GetType().IsEqualNoCase(L"normal")) {
                    userNormalProp = props[k];
                    break;
                  }
                }
                if (userNormalProp.IsValid()) {
                  break;
                }
              }
              if (userNormalProp.IsValid()) {
                // we found it, and we need to attach the op
                CustomOperator op;
                if (attachToExisting) {
                  CRef opRef;
                  opRef.Set(userNormalProp.GetFullName() + L".alembic_normals");
                  op = opRef;
                }
                if (!op.IsValid() && bEnableOperatorCreation) {
                  op = Application().GetFactory().CreateObject(
                      L"alembic_normals");
                  op.AddOutputPort(userNormalProp.GetRef());
                  op.AddInputPort(userNormalProp.GetRef());
                  op.AddInputPort(realTarget);
                  op.Connect();
                }

                if (op.IsValid()) {
                  op.PutParameterValue(L"path", file);
                  op.PutParameterValue(L"identifier", identifier);
                  if (bMultifile) {
                    op.PutParameterValue(L"multifile", true);
                  }
                  if (!timeControlProp.IsValid()) {
                    CRef timeControlRef;
                    if (args.GetCount() > 0) {
                      timeControlRef = args[0];
                    }
                    timeControlProp = timeControlRef;
                  }
                  if (timeControlProp.IsValid())  // Shouldn't we not connect
                                                  // time if normals are
                                                  // constant (we would have
                                                  // faster viewport speeds)
                  {
                    CValue setExprReturn;
                    CValueArray setExprArgs(2);
                    setExprArgs[0] = op.GetFullName() + L".time";
                    setExprArgs[1] =
                        getTimeControlExpression(timeControlProp.GetFullName());
                    Application().ExecuteCommand(L"SetExpr", setExprArgs,
                                                 setExprReturn);
                  }
                }
              }
            }
          }
          if (importUvs) {
            ESS_PROFILE_SCOPE(
                "alembic_create_item_Invoke create_the_operator polymesh_topo "
                "importUvs");
            AbcG::IV2fGeomParam meshUVsParam;
            if (abcMesh.valid()) {
              meshUVsParam = abcMesh.getSchema().getUVsParam();
            }
            else {
              meshUVsParam = abcSubD.getSchema().getUVsParam();
            }
            if (meshUVsParam.valid()) {
              // check if we have a uv set names prop
              CStringArray uvSetNames;
              if (abcMesh.valid()) {
                if (abcMesh.getSchema().getPropertyHeader(".uvSetNames") !=
                    NULL) {
                  Abc::IStringArrayProperty uvSetNamesProp =
                      Abc::IStringArrayProperty(abcMesh.getSchema(),
                                                ".uvSetNames");
                  Abc::StringArraySamplePtr ptr = uvSetNamesProp.getValue(0);
                  for (size_t i = 0; i < ptr->size(); i++) {
                    uvSetNames.Add(CString(ptr->get()[i].c_str()));
                  }
                }
              }
              else {
                if (abcSubD.getSchema().getPropertyHeader(".uvSetNames") !=
                    NULL) {
                  Abc::IStringArrayProperty uvSetNamesProp =
                      Abc::IStringArrayProperty(abcSubD.getSchema(),
                                                ".uvSetNames");
                  Abc::StringArraySamplePtr ptr = uvSetNamesProp.getValue(0);
                  for (size_t i = 0; i < ptr->size(); i++) {
                    uvSetNames.Add(CString(ptr->get()[i].c_str()));
                  }
                }
              }
              if (uvSetNames.GetCount() == 0) {
                uvSetNames.Add(L"Texture_Projection");
              }

              // for each uv set name
              for (LONG uvI = 0; uvI < uvSetNames.GetCount(); uvI++) {
                CRef clusterPropRef;
                if (attachToExisting)
                  clusterPropRef.Set(realTarget.GetAsText() +
                                     L".cls.Texture_Coordinates_AUTO." +
                                     uvSetNames[uvI]);
                if (!clusterPropRef.IsValid()) {
                  CLongArray in_indices;
                  Cluster io_cluster;
                  CStatus status =
                      Primitive(realTarget)
                          .GetParent3DObject()
                          .GetActivePrimitive()
                          .GetGeometry()
                          .AddCluster(L"sample", L"Texture_Coordinates_AUTO",
                                      in_indices, io_cluster);
                  io_cluster.AddProperty("Texture Projection", false,
                                         uvSetNames[uvI]);

                  //   CValue createProjectionReturnVal;
                  //   CValueArray createProjectionArgs(5);
                  //   createProjectionArgs[0] =
                  //   Primitive(realTarget).GetParent3DObject().GetFullName();
                  //   createProjectionArgs[1] = siTxtUV;
                  //   createProjectionArgs[2] = siTxtDefaultPlanarXY;
                  //   createProjectionArgs[3] = L"";
                  //   createProjectionArgs[4] = uvSetNames[uvI];
                  //   Application().ExecuteCommand(L"CreateProjection",createProjectionArgs,createProjectionReturnVal);
                }

                ClusterProperty uvProp;
                CRefArray clusters = meshGeo.GetClusters();
                for (LONG j = 0; j < clusters.GetCount(); j++) {
                  Cluster cluster(clusters[j]);
                  if (!cluster.GetType().IsEqualNoCase(L"sample")) {
                    continue;
                  }
                  CRefArray props(cluster.GetLocalProperties());
                  for (LONG k = 0; k < props.GetCount(); k++) {
                    ClusterProperty prop(props[k]);
                    if (prop.GetType().IsEqualNoCase(L"uvspace") &&
                        prop.GetName().IsEqualNoCase(uvSetNames[uvI])) {
                      uvProp = props[k];
                      break;
                    }
                  }
                  if (uvProp.IsValid()) {
                    break;
                  }
                }

                if (uvProp.IsValid()) {
                  // check if this alembic file has a uv options property
                  bool hasUvOptions = false;
                  if (abcMesh.valid())
                    hasUvOptions = abcMesh.getSchema().getPropertyHeader(
                                       ".uvOptions") != NULL;
                  else
                    hasUvOptions = abcSubD.getSchema().getPropertyHeader(
                                       ".uvOptions") != NULL;
                  if (hasUvOptions) {
                    Abc::IFloatArrayProperty prop;
                    if (abcMesh.valid())
                      prop = Abc::IFloatArrayProperty(abcMesh.getSchema(),
                                                      ".uvOptions");
                    else
                      prop = Abc::IFloatArrayProperty(abcSubD.getSchema(),
                                                      ".uvOptions");

                    // if the prop stores any data
                    if (prop.getNumSamples() > 0) {
                      Abc::FloatArraySamplePtr ptr = prop.getValue(0);
                      if (ptr->size() > 2 * uvI + 1) {
                        bool uWrap = ptr->get()[uvI * 2 + 0] != 0.0f;
                        bool vWrap = ptr->get()[uvI * 2 + 1] != 0.0f;

                        CRefArray children = uvProp.GetNestedObjects();
                        for (LONG i = 0; i < children.GetCount(); i++) {
                          ProjectItem child(children.GetItem(i));
                          CString type = child.GetType();
                          if (type == L"uvprojdef") {
                            child.GetParameter(L"wrap_u").PutValue(uWrap);
                            child.GetParameter(L"wrap_v").PutValue(vWrap);
                            break;
                          }
                        }
                      }
                    }
                  }

                  // we found it, and we need to attach the op
                  CustomOperator op;
                  if (attachToExisting) {
                    CRef opRef;
                    opRef.Set(uvProp.GetFullName() + L".alembic_uvs");
                    op = opRef;
                  }
                  if (!op.IsValid() && bEnableOperatorCreation) {
                    op =
                        Application().GetFactory().CreateObject(L"alembic_uvs");
                    op.AddOutputPort(uvProp.GetRef());
                    op.AddInputPort(uvProp.GetRef());
                    op.AddInputPort(realTarget);
                    op.Connect();
                  }

                  if (op.IsValid()) {
                    op.PutParameterValue(L"path", file);
                    op.PutParameterValue(
                        L"identifier",
                        identifier + CString(L":") + CString(uvI));
                    if (bMultifile) {
                      op.PutParameterValue(L"multifile", true);
                    }

                    if (meshUVsParam.getNumSamples() > 1) {
                      CValue setExprReturn;
                      CValueArray setExprArgs(2);
                      setExprArgs[0] = op.GetFullName() + L".time";
                      setExprArgs[1] = getTimeControlExpression(
                          timeControlProp.GetFullName());
                      Application().ExecuteCommand(L"SetExpr", setExprArgs,
                                                   setExprReturn);
                    }
                  }
                }
              }
            }
          }
        }

        break;
      }
      case alembicItemType_curves: {
        ESS_PROFILE_SCOPE(
            "alembic_create_item_Invoke create_the_operator "
            "alembicItemType_curves");
        // let's setup the ICE tree to load it
        ICETree iceTree;
        CValueArray treeArgs(2);
        CValue treeReturnVal;
        if (attachToExisting) {
          CRef treeRef;
          treeRef.Set(realTarget.GetAsText() + L".ABC_Load_Curves");
          iceTree = treeRef;
        }
        if (!iceTree.IsValid()) {
          treeArgs[0] = L"ABC Load Curves";
          treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
          Application().ExecuteCommand(L"ApplyICEOp", treeArgs, treeReturnVal);
          iceTree = (CRef)treeReturnVal;
        }
        ICECompoundNode node = iceTree.GetCompoundNodes()[0];
        treeArgs[0] = node.GetFullName() + L".path_string";
        treeArgs[1] = file;
        Application().ExecuteCommand(L"SetValue", treeArgs, treeReturnVal);
        treeArgs[0] = node.GetFullName() + L".identifier_string";
        treeArgs[1] = identifier;
        Application().ExecuteCommand(L"SetValue", treeArgs, treeReturnVal);

        if (bMultifile) {
          treeArgs[0] = node.GetFullName() + L".multifile";
          treeArgs[1] = true;
          Application().ExecuteCommand(L"SetValue", treeArgs, treeReturnVal);
        }

        if (isAnimated) {
          // check if we have a timecontrol in the args
          CRef timeControlRef;
          if (args.GetCount() > 0) {
            timeControlRef = args[0];
          }
          CustomProperty timeControlProp = timeControlRef;
          if (timeControlProp.IsValid()) {
            treeArgs[0] = node.GetFullName() + L".TimeControl";
            treeArgs[1] = timeControlProp.GetFullName();
            Application().ExecuteCommand(L"SetValue", treeArgs, treeReturnVal);
          }
        }

        // store the return value
        returnVal = iceTree.GetRef();
        break;
      }
      case alembicItemType_points: {
        ESS_PROFILE_SCOPE(
            "alembic_create_item_Invoke create_the_operator "
            "alembicItemType_points");
        // let's setup the ICE tree to load it

        CValueArray treeArgs(2);
        CValue treeReturnVal;

        // we need to check if we have instances....
        AbcG::IPoints abcPoints(abcObject, Abc::kWrapExisting);
        if (!abcPoints.valid()) {
          return CStatus::OK;
        }

        Abc::IStringArrayProperty shapeInstanceNamesProp;
        if (getArbGeomParamPropertyAlembic(abcPoints, "instancenames",
                                           shapeInstanceNamesProp)) {
          if (shapeInstanceNamesProp.getNumSamples() > 0) {
            Abc::StringArraySamplePtr shapeInstanceNamesPtr =
                shapeInstanceNamesProp.getValue(
                    shapeInstanceNamesProp.getNumSamples() - 1);
            if (shapeInstanceNamesPtr->size() > 0) {
              ICETree iceTree;
              if (attachToExisting) {
                CRef treeRef;
                treeRef.Set(realTarget.GetAsText() + L".ABC_Instance_Shapes");
                iceTree = treeRef;
              }
              if (!iceTree.IsValid()) {
                treeArgs[0] = L"ABC Instance Shapes";
                treeArgs[1] =
                    Primitive(realTarget).GetParent3DObject().GetFullName();
                Application().ExecuteCommand(L"ApplyICEOp", treeArgs,
                                             treeReturnVal);
                iceTree = (CRef)treeReturnVal;
              }

              for (size_t j = 0; j < shapeInstanceNamesPtr->size(); j++) {
                std::string instanceIdentifier =
                    shapeInstanceNamesPtr->get()[j];
                // replace spaces with underscores
                for (int c = 0; c < instanceIdentifier.size(); c++) {
                  if (instanceIdentifier[c] == ' ') {
                    instanceIdentifier[c] = '_';
                  }
                }

                CString fullName = getFullNameFromIdentifier(
                    importRootNode, instanceIdentifier);
                treeArgs[0] = iceTree.GetFullName() +
                              L".ABC_Instance_Shapes.Reference" +
                              CString((LONG)j);
                treeArgs[1] = fullName;
                CStatus status = Application().ExecuteCommand(
                    L"SetValue", treeArgs, treeReturnVal);
                if (status != CStatus::OK) {
                  ESS_LOG_WARNING("Failed set ABC_Instance_Shapes.Reference");
                }

                // also check if we have this object in the scene
                if (hasStandinSupport()) {
                  CRef ref;
                  ref.Set(fullName);
                  X3DObject x3d(ref);
                  if (x3d.IsValid()) {
                    // disable deferred loading on the instance sources
                    CRef standinPropRef;
                    standinPropRef.Set(fullName + L".arnold_standin");
                    Property prop(standinPropRef);
                    if (prop.IsValid()) {
                      prop.PutParameterValue(L"deferredLoading", false);
                    }

                    // enable hiding the instance masters
                    CRef visPropRef;
                    visPropRef.Set(fullName + L".visibility");
                    prop = Property(visPropRef);
                    if (prop.IsValid()) {
                      prop.PutParameterValue(L"hidemaster", true);
                    }
                  }
                }
              }
            }
          }
        }

        ICETree iceTree;
        if (attachToExisting) {
          CRef treeRef;
          treeRef.Set(realTarget.GetAsText() + L".ABC_Load_Points");
          iceTree = treeRef;
        }
        if (!iceTree.IsValid()) {
          treeArgs[0] = L"ABC Load Points";
          treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
          CStatus status = Application().ExecuteCommand(L"ApplyICEOp", treeArgs,
                                                        treeReturnVal);
          if (status != CStatus::OK) {
            ESS_LOG_WARNING("Failed to ApplyICEOp ABC_Load_Points");
          }
          iceTree = (CRef)treeReturnVal;
        }

        ICECompoundNode node = iceTree.GetCompoundNodes()[0];
        treeArgs[0] = node.GetFullName() + L".path_string";
        treeArgs[1] = file;
        CStatus status =
            Application().ExecuteCommand(L"SetValue", treeArgs, treeReturnVal);
        if (status != CStatus::OK) {
          ESS_LOG_WARNING("Failed set SetValue of path_string");
          ESS_LOG_WARNING(
              "nodeFullName: " << node.GetFullName().GetAsciiString());
        }

        treeArgs[0] = node.GetFullName() + L".identifier_string";
        treeArgs[1] = identifier;
        Application().ExecuteCommand(L"SetValue", treeArgs, treeReturnVal);

        if (bMultifile) {
          treeArgs[0] = node.GetFullName() + L".multifile";
          treeArgs[1] = true;
          Application().ExecuteCommand(L"SetValue", treeArgs, treeReturnVal);
        }

        if (isAnimated) {
          // check if we have a timeControl in the args
          CRef timeControlRef;
          if (args.GetCount() > 0) {
            timeControlRef = args[0];
          }
          CustomProperty timeControlProp = timeControlRef;
          if (timeControlProp.IsValid()) {
            treeArgs[0] = node.GetFullName() + L".TimeControl";
            treeArgs[1] = timeControlProp.GetFullName();
            Application().ExecuteCommand(L"SetValue", treeArgs, treeReturnVal);
          }
        }

        // store the return value
        returnVal = iceTree.GetRef();
        break;
      }
      case alembicItemType_metadata: {
        ESS_PROFILE_SCOPE(
            "alembic_create_item_Invoke create_the_operator "
            "alembicItemType_metadata");
        Abc::ICompoundProperty abcCompound = getCompoundFromObject(abcObject);
        if (abcCompound.getPropertyHeader(".metadata") == NULL) {
          break;
        }

        Abc::IStringArrayProperty metaDataProp =
            Abc::IStringArrayProperty(abcCompound, ".metadata");
        Abc::StringArraySamplePtr metaDataPtr = metaDataProp.getValue(0);
        if (metaDataPtr->size() != 20) {
          break;
        }

        // check if we already have the metadataprop
        CustomProperty xsiProp;
        CRefArray props = x3d.GetLocalProperties();
        for (LONG i = 0; i < props.GetCount(); i++) {
          CustomProperty prop(props[i]);
          if (!prop.IsValid()) {
            continue;
          }
          if (!prop.GetType().IsEqualNoCase(L"alembic_metadata")) {
            continue;
          }
          xsiProp = prop;
          break;
        }
        if (!xsiProp.IsValid()) {
          xsiProp = x3d.AddProperty(L"alembic_metadata");
        }

        // set all values
        size_t offset = 0;
        for (LONG i = 0; i < 10; i++) {
          xsiProp.PutParameterValue(
              L"name" + CString(i),
              CString(metaDataPtr->get()[offset++].c_str()));
          xsiProp.PutParameterValue(
              L"value" + CString(i),
              CString(metaDataPtr->get()[offset++].c_str()));
        }

        // store the return value
        returnVal = xsiProp.GetRef();
        break;
      }
      case alembicItemType_timecontrol: {
        ESS_PROFILE_SCOPE(
            "alembic_create_item_Invoke create_the_operator "
            "alembicItemType_timecontrol");
        CValueArray setExprArgs(2);
        CValue setExprReturn;
        CustomProperty timeControl =
            (CustomProperty)x3d.AddProperty(L"alembic_timecontrol");

        // prepare values for the setexpr command
        setExprArgs[0] = timeControl.GetFullName() + L".current";
        setExprArgs[1] = L"T";
        Application().ExecuteCommand(L"SetExpr", setExprArgs, setExprReturn);

        // store the return value
        returnVal = timeControl.GetRef();
        break;
      }
      case alembicItemType_standin: {
        ESS_PROFILE_SCOPE(
            "alembic_create_item_Invoke create_the_operator "
            "alembicItemType_standin");
        // create an arnold property on the x3d if we don't have it yet!
        if (!hasStandinSupport()) {
          Application().LogMessage(
              L"[ExocortexAlembic] There is no standin support. Please use a "
              L"renderer supported standins.",
              siErrorMsg);
          return CStatus::InvalidArgument;
        }

        X3DObject sourceX3D = ProjectItem(realTarget).GetParent3DObject();
        CString projectItemName = ProjectItem(realTarget).GetFullName();
        CString sourceX3DFullName = sourceX3D.GetFullName();

        // let's see if we have the standin property already
        CustomProperty arnoldProp;
        CRef propRef;
        propRef.Set(sourceX3D.GetFullName() + L".arnold_standin");
        if (propRef.IsValid()) {
          arnoldProp = CustomProperty(propRef);
        }
        else {
          arnoldProp = sourceX3D.AddProperty(L"arnold_standin", false);
        }

        // now check if the operator alrady exists
        CRef opRef;
        opRef.Set(arnoldProp.GetFullName() + L".alembic_standinop");
        if (!opRef.IsValid()) {
          CustomOperator op =
              Application().GetFactory().CreateObject(L"alembic_standinop");
          op.AddOutputPort(arnoldProp.GetRef());
          op.AddInputPort(realTarget);
          op.Connect();

          // create the timecontrol expression
          // check if we have a timecontrol in the args
          CRef timeControlRef;
          if (args.GetCount() > 0) {
            timeControlRef = args[0];
          }
          Property timeControlProp = timeControlRef;
          if (timeControlProp.IsValid()) {
            CValue setExprReturn;
            CValueArray setExprArgs(2);
            setExprArgs[0] = op.GetFullName() + L".time";
            setExprArgs[1] =
                getTimeControlExpression(timeControlProp.GetFullName());
            Application().ExecuteCommand(L"SetExpr", setExprArgs,
                                         setExprReturn);
          }
        }

        break;
      }
      default:
        break;
    }
  }

  return CStatus::OK;
}

CStatus alembic_create_item_Invoke(const CString& type,
                                   const CRef& importRootNode,
                                   const CRef& target, const CString& file,
                                   const CString& identifier,
                                   bool attachToExisting,
                                   const CValueArray& args)
{
  CValue returnVal;
  alembic_create_item_Invoke(type, importRootNode, target, file, identifier,
                             attachToExisting, args, returnVal);
  return CStatus::OK;
}

CStatus alembic_create_item_Invoke(const CString& type,
                                   const CRef& importRootNode,
                                   const CRef& target, const CString& file,
                                   const CString& identifier,
                                   bool attachToExisting)
{
  CValueArray args(0);
  alembic_create_item_Invoke(type, importRootNode, target, file, identifier,
                             attachToExisting, args);
  return CStatus::OK;
}

ESS_CALLBACK_START(alembic_create_item_Execute, CRef&)
Context ctxt(in_ctxt);
CValueArray args = ctxt.GetAttribute(L"Arguments");
CString type = args[0];
// CRef importRootNode = args[1];
CRef target = args[1];
CString file = args[2];
CString identifier = args[3];
bool reattach = args[4];
CValueArray additionalArgs;
for (LONG i = 5; i < args.GetCount(); i++) {
  additionalArgs.Add(args[i]);
}
CValue returnVal;
CStatus result =
    alembic_create_item_Invoke(type, target, target, file, identifier, reattach,
                               additionalArgs, returnVal);
ctxt.PutAttribute(L"ReturnValue", returnVal);
return result;
ESS_CALLBACK_END

CRef setupTimeControl(SceneNodeAlembicPtr fileXformNode,
                      XSI::CRef importRootNode)
{
  {
    CString rootPath = importRootNode.GetAsText();
    rootPath += ".alembic_timecontrol";

    // ESS_LOG_WARNING("timeControl: "<<rootPath.GetAsciiString());

    // create the timecontrol
    CRef timeRef;
    timeRef.Set(rootPath);
    CustomProperty timeControl = timeRef;

    CValueArray setExprArgs(2);
    CValue setExprReturn;
    if (!timeControl.IsValid()) {
      // ESS_LOG_WARNING("creating time control under
      // "<<rootPath.GetAsciiString());

      X3DObject root(importRootNode);
      timeControl = root.AddProperty(L"alembic_timecontrol");

      // prepare values for the setexpr command
      setExprArgs[0] = timeControl.GetFullName() + L".current";
      setExprArgs[1] = L"T";
      Application().ExecuteCommand(L"SetExpr", setExprArgs, setExprReturn);
    }

    timeRef.Set(rootPath);

    if (!timeRef.IsValid()) {
      ESS_LOG_ERROR("Could not find alembic_timecontrol");
    }

    return timeRef;
    // now update the args to use the timecontrol instead
    // setExprArgs[1] = timeControl.GetFullName()+L".current *
    // "+timeControl.GetFullName()+L".factor +
    // "+timeControl.GetFullName()+L".offset";
  }

  // CRef timeRef;
  // CString timeControlPath = importRootNode.GetAsText();
  // timeControlPath += ".alembic_timecontrol";
  // timeRef.Set(timeControlPath);
  ////CustomProperty timeControl = timeRef;
  //
  // if(!timeRef.IsValid()){
  //   ESS_LOG_ERROR("Could not find alembic_timecontrol");
  //   return false;
  //}
}

// the last parameter is ignored if attach to exising is active (since we are
// not creating a new node)
bool createNode(SceneNodeXSI* appNode, SceneNodeAlembicPtr fileNode,
                const IJobStringParser& jobParams, SceneNodePtr& returnNode,
                bool bAttachToExisting)
{
  // the appNode parameter is either the parent if adding a new node to the
  // scene, or the node to replace if doing attach to existing

  XSI::CRef importRootNode;
  {
    IJobStringParser& nonConstJobParams = (IJobStringParser&)jobParams;
    importRootNode.Set(
        nonConstJobParams.extraParameters["appRootPath"].c_str());
  }

  CString filename = CString(jobParams.filename.c_str());
  const bool& attachToExisting = bAttachToExisting;
  bool usePerModelTimeControls =
      jobParams.timeControl == timeControlOptions::ROOT_MODELS;
  // const bool& importStandins = jobParams.importStandinProperties;
  // const bool& importBboxes = jobParams.importBoundingBoxes;
  // const bool& failOnUnsupported = jobParams.failOnUnsupported;

  // CRef timeRef;
  // CString timeControlPath = importRootNode.GetAsText();
  // timeControlPath += ".alembic_timecontrol";
  // timeRef.Set(timeControlPath);

  // if(!timeRef.IsValid()){
  //   ESS_LOG_ERROR("Could not find alembic_timecontrol");
  //   return false;
  //}

  // CustomProperty timeControl = timeRef;
  CValueArray createItemArgs(8);
  // createItemArgs[0] = timeRef; //this is now intialized later on
  createItemArgs[1] = jobParams.importFacesets;
  createItemArgs[2] = jobParams.importNormals;
  createItemArgs[3] = jobParams.importUVs;
  createItemArgs[4] = jobParams.importVisibilityControllers;
  createItemArgs[5] = jobParams.useMultiFile;
  createItemArgs[6] = jobParams.operatorCreationForExistingNodes;
  createItemArgs[7] = jobParams.importTransformControllers;

  // the transform

  const Abc::IObject& iObj = fileNode->getObject();
  CString name =
      truncateName(fileNode->name.c_str());  // iObj.getName().c_str());

  // if(jobParams.stripMayaNamespaces){
  //   name = stripNamespacePrefix(name);
  //}

  if (AbcG::IXform::matches(iObj.getMetaData())) {
    AbcG::IXform xform(iObj, Abc::kWrapExisting);
    XSI_XformTypes::xte xte = getXformType(xform);
    if (xte == XSI_XformTypes::UNKNOWN) {  // if UNKNOWN, default chosen based
      // on import option
      xte = jobParams.xformTypes;
    }

    CRef nodeRef;
    if (attachToExisting) {
      ESS_PROFILE_SCOPE("attachToExisting");
      nodeRef = appNode->nodeRef;

      // if(!x3dobject.GetType().IsEqualNoCase(L"#model") &&
      // !x3dobject.GetType().IsEqualNoCase(L"null")){
      //   x3dobject.ResetObject();
      //}

      if (!nodeRef.IsValid()) {
        ESS_LOG_ERROR("Could not attach xform " << iObj.getFullName());
        return false;
      }

      returnNode = fileNode;

      fileNode->setAttached(true);
    }
    else {
      X3DObject parentX3DObject(appNode->nodeRef);

      if (xte == XSI_XformTypes::XMODEL) {
        ESS_PROFILE_SCOPE("creatNode Model");
        CRefArray objects;
        Model model;
        parentX3DObject.AddModel(objects, name, model);
        nodeRef = model.GetRef();
      }
      else {
        ESS_PROFILE_SCOPE("creatNode Null");
        Null null;
        parentX3DObject.AddNull(name, null);
        nodeRef = null.GetRef();
      }

      if (!nodeRef.IsValid()) {
        ESS_LOG_ERROR("Could not create xform " << iObj.getFullName());
        return false;
      }

      returnNode = SceneNodePtr(new SceneNodeXSI(nodeRef));
    }

    // keep track of the app node the alembic node maps to
    // needed from time control per model feature
    fileNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();

    if (usePerModelTimeControls) {
      createItemArgs[0] = setupTimeControl(
          fileNode,
          findTimeControlDccIdentifier(fileNode, importRootNode, xte));
    }
    else {
      createItemArgs[0] = setupTimeControl(fileNode, importRootNode);
    }

    // load metadata
    alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef,
                               filename, iObj.getFullName().c_str(),
                               attachToExisting, createItemArgs);

    // load xform
    alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef,
                               filename, iObj.getFullName().c_str(),
                               attachToExisting, createItemArgs);

    // load visibility
    alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef,
                               filename, iObj.getFullName().c_str(),
                               attachToExisting, createItemArgs);
  }
  else {
    std::stringstream s;
    s << "Unsupported Alembic type: " << iObj.getFullName().c_str();
    if (jobParams.failOnUnsupported) {
      ESS_LOG_ERROR(s.str().c_str());
      return false;
    }
    ESS_LOG_WARNING(s.str().c_str());
  }

  return true;
}

bool validate(CRef nodeRef, CString fileNodeType, Abc::IObject shapeObj)
{
  if (!nodeRef.IsValid()) {
    ESS_LOG_ERROR("Could not attach " << fileNodeType.GetAsciiString() << " "
                                      << shapeObj.getFullName());
    return false;
  }

  X3DObject x3dobject(nodeRef);
  CString type = x3dobject.GetType();
  if (!type.IsEqualNoCase(fileNodeType) &&
      !type.IsEqualNoCase("null")) {  // allow all shape type to replace a null
    ESS_LOG_ERROR("Cannot attach " << shapeObj.getFullName() << " to a "
                                   << type.GetAsciiString() << " node.");
    return false;
  }

  if (type.IsEqualNoCase("null")) {
    ESS_LOG_WARNING("Validate: Replacing null with shape " +
                    shapeObj.getFullName());
    x3dobject.ResetObject();
  }

  return true;
}

bool createMergeableNode(SceneNodeXSI* appNode,
                         SceneNodeAlembicPtr fileXformNode,
                         SceneNodeAlembicPtr fileShapeNode,
                         const IJobStringParser& jobParams,
                         SceneNodePtr& returnNode, bool bAttachToExisting)
{
  // the appNode parameter is either the parent if adding a new node to the
  // scene, or the node to replace if doing attach to existing

  XSI::CRef importRootNode;
  {
    IJobStringParser& nonConstJobParams = (IJobStringParser&)jobParams;
    importRootNode.Set(
        nonConstJobParams.extraParameters["appRootPath"].c_str());
  }

  bool usePerModelTimeControls =
      jobParams.timeControl == timeControlOptions::ROOT_MODELS;

  const CString filename(jobParams.filename.c_str());
  const bool& attachToExisting = bAttachToExisting;
  const bool& importStandins = jobParams.importStandinProperties;
  const bool& importBboxes = jobParams.importBoundingBoxes;
  const bool& failOnUnsupported = jobParams.failOnUnsupported;

  // CRef timeRef;
  // CString timeControlPath = importRootNode.GetAsText();
  // timeControlPath += ".alembic_timecontrol";
  // timeRef.Set(timeControlPath);
  ////CustomProperty timeControl = timeRef;
  //
  // if(!timeRef.IsValid()){
  //   ESS_LOG_ERROR("Could not find alembic_timecontrol");
  //   return false;
  //}

  // store the time control in a value array
  CValueArray createItemArgs(8);
  // createItemArgs[0] = timeRef;//this is now intialized later on
  createItemArgs[1] = jobParams.importFacesets;
  createItemArgs[2] = jobParams.importNormals;
  createItemArgs[3] = jobParams.importUVs;
  createItemArgs[4] = jobParams.importVisibilityControllers;
  createItemArgs[5] = jobParams.useMultiFile;
  createItemArgs[6] = jobParams.operatorCreationForExistingNodes;
  createItemArgs[7] = jobParams.importTransformControllers;

  Abc::IObject shapeObj = fileShapeNode->getObject();
  const char* shapeFullName = shapeObj.getFullName().c_str();
  const char* xformFullName = NULL;

  CString newAppNodeName;
  if (fileXformNode) {
    // if we will merge will the shape node with its parent transform, we use
    // the name of the transform node
    //(not the shape). This is done to avoid namespace conflicts.
    xformFullName = fileXformNode->getObject().getFullName().c_str();
    newAppNodeName = truncateName(
        fileXformNode->name.c_str());  // getObject().getName().c_str());

    fileXformNode->setMerged(true);
    fileShapeNode->setMerged(true);

    // ESS_LOG_WARNING("xformName: "<<xformFullName<<" - shapeName:
    // "<<shapeFullName);
  }
  else {
    newAppNodeName = truncateName(
        fileShapeNode->name.c_str());  // shapeObj.getName().c_str());

    // ESS_LOG_WARNING("shapeName: "<<shapeFullName);
  }
  // EC_LOG_INFO( "Object name: " << newAppNodeName.GetAsciiString() );

  // if(jobParams.stripMayaNamespaces){
  //  newAppNodeName = stripNamespacePrefix(newAppNodeName);
  //}

  if (AbcG::ICamera::matches(shapeObj.getMetaData())) {
    // ESS_LOG_WARNING("Import ICamera");
    // let's create a camera
    CRef nodeRef;
    Camera camera;
    if (attachToExisting) {
      ESS_PROFILE_SCOPE("attachToExisting");
      nodeRef = appNode->nodeRef;

      if (!validate(nodeRef, CString("camera"), shapeObj)) {
        return false;
      }

      camera = nodeRef;

      returnNode = fileShapeNode;

      if (fileXformNode) {
        fileXformNode->setAttached(true);
      }
      fileShapeNode->setAttached(true);
    }
    else {
      X3DObject parentX3DObject(appNode->nodeRef);
      parentX3DObject.AddCamera(L"Camera", newAppNodeName, camera);
      nodeRef = camera.GetRef();

      if (!nodeRef.IsValid()) {
        ESS_LOG_ERROR("Could not create camera " << shapeObj.getFullName());
        return false;
      }

      returnNode = SceneNodePtr(new SceneNodeXSI(nodeRef));
    }

    if (fileXformNode) {
      fileXformNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();
    }

    if (usePerModelTimeControls && fileXformNode) {
      createItemArgs[0] = setupTimeControl(
          fileXformNode,
          findTimeControlDccIdentifier(fileXformNode, importRootNode,
                                       jobParams.xformTypes));
    }
    else {
      createItemArgs[0] = setupTimeControl(fileXformNode, importRootNode);
    }

    // delete the interest
    CValueArray deleteArgs(1);
    deleteArgs[0] = camera.GetInterest().GetFullName();
    CValue setExprReturn;
    Application().ExecuteCommand(L"DeleteObj", deleteArgs, setExprReturn);

    // load metadata
    alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef,
                               filename, shapeFullName, attachToExisting,
                               createItemArgs);

    // let's setup the xform op
    if (fileXformNode) {
      alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef,
                                 filename, xformFullName, attachToExisting,
                                 createItemArgs);
    }
    // load visibility
    alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef,
                               filename, shapeFullName, attachToExisting,
                               createItemArgs);

    // load camera
    alembic_create_item_Invoke(L"alembic_camera", importRootNode, nodeRef,
                               filename, shapeFullName, attachToExisting,
                               createItemArgs);
  }
  else if (AbcG::IPolyMesh::matches(shapeObj.getMetaData()) ||
           AbcG::ISubD::matches(shapeObj.getMetaData())) {
    // ESS_LOG_WARNING("Import IPolyMesh");

    X3DObject meshObj;
    CRef nodeRef;
    if (attachToExisting) {
      ESS_PROFILE_SCOPE("attachToExisting");
      nodeRef = appNode->nodeRef;

      if (!validate(nodeRef, CString("PolyMsh"), shapeObj)) {
        return false;
      }

      meshObj = nodeRef;

      returnNode = fileShapeNode;

      if (fileXformNode) {
        fileXformNode->setAttached(true);
      }
      fileShapeNode->setAttached(true);
    }
    else {
      X3DObject parentX3DObject(appNode->nodeRef);

      XSI::CStatus status;
      if (importBboxes) {
        status = parentX3DObject.AddGeometry(L"Cube", L"MeshSurface",
                                             newAppNodeName, meshObj);
      }
      else {
        ESS_PROFILE_SCOPE(
            "createMergeableNode - AddPrimitive(EmptyPolygonMesh)");
        CVector3Array verts(0);
        CLongArray indices(0);
        status = parentX3DObject.AddPolygonMesh(verts, indices, newAppNodeName,
                                                meshObj);
        // status = parentX3DObject..AddPrimitive(L"EmptyPolygonMesh",
        // newAppNodeName, meshObj);//very slow, don't do this!
      }
      nodeRef = meshObj.GetRef();

      if (!nodeRef.IsValid()) {
        ESS_LOG_ERROR("Could not create polymesh " << shapeObj.getFullName());
      }

      returnNode = SceneNodePtr(new SceneNodeXSI(meshObj.GetRef()));
    }

    if (fileXformNode) {
      fileXformNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();
    }

    if (usePerModelTimeControls && fileXformNode) {
      createItemArgs[0] = setupTimeControl(
          fileXformNode,
          findTimeControlDccIdentifier(fileXformNode, importRootNode,
                                       jobParams.xformTypes));
    }
    else {
      createItemArgs[0] = setupTimeControl(fileXformNode, importRootNode);
    }

    // make the geometry approx local
    CValue makeLocalReturn;
    CValueArray makeLocalArgs(2);
    makeLocalArgs[0] = meshObj.GetFullName() + L".geomapprox";
    makeLocalArgs[1] = siNodePropagation;
    Application().ExecuteCommand(L"MakeLocal", makeLocalArgs, makeLocalReturn);

    // load metadata
    alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef,
                               filename, shapeFullName, attachToExisting,
                               createItemArgs);

    // create the topo op
    CRef returnOpRef;
    if (!importBboxes && !fileShapeNode->pObjCache->isMeshPointCache) {
      CValue returnedOpVal;
      alembic_create_item_Invoke(
          L"alembic_polymesh_topo", importRootNode, nodeRef, filename,
          shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
      returnOpRef = (CRef)returnedOpVal;
    }

    // load visibility
    alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef,
                               filename, shapeFullName, attachToExisting,
                               createItemArgs);

    bool bLoadGeoApprox = false;

    if (!importBboxes) {
      if (AbcG::ISubD::matches(shapeObj.getMetaData())) {
        bLoadGeoApprox = true;
      }
      else {
        AbcG::IPolyMesh abcMesh = AbcG::IPolyMesh(shapeObj, Abc::kWrapExisting);
        bLoadGeoApprox = abcMesh.getSchema().getPropertyHeader(
                             ".faceVaryingInterpolateBoundary") != NULL;
      }
    }
    if (bLoadGeoApprox && jobParams.enableSubD) {
      alembic_create_item_Invoke(L"alembic_geomapprox", importRootNode, nodeRef,
                                 filename, shapeFullName, attachToExisting,
                                 createItemArgs);
    }

    // let's setup the xform op
    if (fileXformNode) {
      alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef,
                                 filename, xformFullName, attachToExisting,
                                 createItemArgs);
    }

    // let's setup the positions op
    if (importBboxes) {
      CValue returnedOpVal;
      alembic_create_item_Invoke(L"alembic_bbox", importRootNode, nodeRef,
                                 filename, shapeFullName, attachToExisting,
                                 createItemArgs, returnedOpVal);
      returnOpRef = (CRef)returnedOpVal;
    }
    else {
      // TODO: what is check for? what should be done in the case of SUBD
      // only add the point position operator if we don't have dynamic topology
      bool receivesExpression = fileShapeNode->pObjCache->isMeshTopoDynamic;

      if (!receivesExpression) {
        CValue returnedOpVal;
        alembic_create_item_Invoke(L"alembic_polymesh", importRootNode, nodeRef,
                                   filename, shapeFullName, attachToExisting,
                                   createItemArgs, returnedOpVal);
        returnOpRef = (CRef)returnedOpVal;
      }
    }

    // load standin property
    if (importStandins && returnOpRef.IsValid()) {
      alembic_create_item_Invoke(L"alembic_standin", importRootNode,
                                 returnOpRef, filename, shapeFullName,
                                 attachToExisting, createItemArgs);
    }
  }

  else if (AbcG::INuPatch::matches(shapeObj.getMetaData())) {
    // ESS_LOG_WARNING("Import INuPatch");
    CRef nodeRef;
    X3DObject nurbsObj;
    if (attachToExisting) {
      ESS_PROFILE_SCOPE("attachToExisting");
      nodeRef = appNode->nodeRef;

      if (!validate(nodeRef, CString("surfmsh"), shapeObj)) {
        return false;
      }
      nurbsObj = nodeRef;

      returnNode = fileShapeNode;

      if (fileXformNode) {
        fileXformNode->setAttached(true);
      }
      fileShapeNode->setAttached(true);
    }

    if (fileXformNode) {
      fileXformNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();
    }

    if (usePerModelTimeControls && fileXformNode) {
      createItemArgs[0] = setupTimeControl(
          fileXformNode,
          findTimeControlDccIdentifier(fileXformNode, importRootNode,
                                       jobParams.xformTypes));
    }
    else {
      createItemArgs[0] = setupTimeControl(fileXformNode, importRootNode);
    }

    if (!nurbsObj.IsValid()) {
      if (failOnUnsupported) {
        ESS_LOG_ERROR(
            "Can't create new Nurb surfaces, can only attach.  Unsupported "
            "Alembic type: "
                << shapeObj.getFullName().c_str(););
        return false;
      }
      ESS_LOG_WARNING(
          "Can't create new Nurb surfaces, can only attach.  Unsupported "
          "Alembic type: "
              << shapeObj.getFullName().c_str(););
      return true;
    }

    // load metadata
    alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef,
                               filename, shapeFullName, attachToExisting,
                               createItemArgs);

    // let's setup the xform op
    if (fileXformNode) {
      alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef,
                                 filename, xformFullName, attachToExisting,
                                 createItemArgs);
    }

    alembic_create_item_Invoke(L"alembic_nurbs", importRootNode, nodeRef,
                               filename, shapeFullName, attachToExisting,
                               createItemArgs);
  }
  else if (AbcG::ICurves::matches(shapeObj.getMetaData())) {
    // ESS_LOG_WARNING("Import ICurves");
    // let's create a crvlist
    AbcG::ICurves curveIObject(shapeObj, Abc::kWrapExisting);
    AbcG::ICurvesSchema curveSchema = curveIObject.getSchema();
    AbcG::ICurvesSchema::Sample curveSample = curveSchema.getValue();

    // check for valid curve types...!
    if (curveSample.getType() != AbcG::kLinear &&
        curveSample.getType() != AbcG::kCubic) {
      std::stringstream s;
      s << "Can't create non-linear/non-cubic Curves.  Unsupported Alembic "
           "type: "
        << shapeObj.getFullName().c_str();
      if (failOnUnsupported) {
        ESS_LOG_ERROR(s.str().c_str());
        return false;
      }
      // ESS_LOG_WARNING( s.str().c_str() );
    }

    // now let's check if we are looking at a curves node with color and radii

    bool useParticles = false;
    {
      Abc::IFloatArrayProperty propRadius;
      if (getArbGeomParamPropertyAlembic(curveIObject, "radius", propRadius)) {
        useParticles = true;
      }
      Abc::IC4fArrayProperty propColor;
      if (getArbGeomParamPropertyAlembic(curveIObject, "color", propColor)) {
        useParticles = true;
      }
      if (jobParams.importCurvesAsStrands) {
        useParticles = true;
      }
    }

    /*bool useParticles = curveSchema.getPropertyHeader( ".radius" ) != NULL ||
    curveSchema.getPropertyHeader( ".color" ) != NULL;
    if(useParticles)
    {
       if( curveSchema.getPropertyHeader( ".radius" ) != NULL )
       {
          Abc::IFloatArrayProperty prop = Abc::IFloatArrayProperty( curveSchema,
    ".radius" );
          if(!prop.valid())
             useParticles = false;
          else if(prop.getNumSamples() == 0)
             useParticles = false;
       }
       else if( curveSchema.getPropertyHeader( ".color" ) != NULL )
       {
          Abc::IC4fArrayProperty prop = Abc::IC4fArrayProperty( curveSchema,
    ".color" );
          if(!prop.valid())
             useParticles = false;
          else if(prop.getNumSamples() == 0)
             useParticles = false;
       }
    }*/

    if (useParticles) {
      CRef nodeRef;
      if (attachToExisting) {
        ESS_PROFILE_SCOPE("attachToExisting");
        nodeRef = appNode->nodeRef;

        if (!validate(nodeRef, CString("pointcloud"), shapeObj)) {
          return false;
        }

        returnNode = fileShapeNode;

        if (fileXformNode) {
          fileXformNode->setAttached(true);
        }
        fileShapeNode->setAttached(true);
      }
      else {
        X3DObject parentX3DObject(appNode->nodeRef);
        X3DObject pointsObj;
        if (importBboxes) {
          parentX3DObject.AddGeometry(L"Cube", L"MeshSurface", newAppNodeName,
                                      pointsObj);
        }
        else {
          parentX3DObject.AddPrimitive(L"PointCloud", newAppNodeName,
                                       pointsObj);
        }
        nodeRef = pointsObj.GetRef();

        if (!nodeRef.IsValid()) {
          ESS_LOG_ERROR("Could not create curve " << shapeObj.getFullName());
        }
        returnNode = SceneNodePtr(new SceneNodeXSI(nodeRef));
      }

      if (fileXformNode) {
        fileXformNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();
      }

      if (usePerModelTimeControls && fileXformNode) {
        createItemArgs[0] = setupTimeControl(
            fileXformNode,
            findTimeControlDccIdentifier(fileXformNode, importRootNode,
                                         jobParams.xformTypes));
      }
      else {
        createItemArgs[0] = setupTimeControl(fileXformNode, importRootNode);
      }

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef,
                                 filename, shapeFullName, attachToExisting,
                                 createItemArgs);

      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef,
                                 filename, shapeFullName, attachToExisting,
                                 createItemArgs);

      // load curves
      CRef returnOpRef;
      if (importBboxes) {
        CValue returnedOpVal;
        alembic_create_item_Invoke(L"alembic_bbox", importRootNode, nodeRef,
                                   filename, shapeFullName, attachToExisting,
                                   createItemArgs, returnedOpVal);
        returnOpRef = (CRef)returnedOpVal;
      }
      else {
        CValue returnedOpVal;
        alembic_create_item_Invoke(L"alembic_curves", importRootNode, nodeRef,
                                   filename, shapeFullName, attachToExisting,
                                   createItemArgs, returnedOpVal);
        returnOpRef = (CRef)returnedOpVal;
      }

      // let's setup the xform op
      if (fileXformNode) {
        alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef,
                                   filename, xformFullName, attachToExisting,
                                   createItemArgs);
      }

      // load standin property
      if (importStandins && returnOpRef.IsValid()) {
        alembic_create_item_Invoke(L"alembic_standin", importRootNode,
                                   returnOpRef, filename, shapeFullName,
                                   attachToExisting, createItemArgs);
      }
    }
    else {
      X3DObject curveObj;
      CRef nodeRef;
      if (attachToExisting) {
        ESS_PROFILE_SCOPE("attachToExisting");
        nodeRef = appNode->nodeRef;

        if (!nodeRef.IsValid()) {
          ESS_LOG_ERROR("Could not attach curve " << shapeObj.getFullName());
        }

        X3DObject x3dobject(nodeRef);
        CString type = x3dobject.GetType();
        if (!x3dobject.GetType().IsEqualNoCase(L"crvlist") &&
            !x3dobject.GetType().IsEqualNoCase(L"hair") &&
            !type.IsEqualNoCase("null")) {
          ESS_LOG_ERROR("Cannot attach " << shapeObj.getFullName() << " to a "
                                         << type.GetAsciiString() << " node.");
          return false;
        }

        if (type.IsEqualNoCase("null")) {
          ESS_LOG_WARNING("Replacing null with shape " +
                          shapeObj.getFullName());
          x3dobject.ResetObject();
        }

        curveObj = nodeRef;

        returnNode = fileShapeNode;

        if (fileXformNode) {
          fileXformNode->setAttached(true);
        }
        fileShapeNode->setAttached(true);
      }
      else {
        X3DObject parentX3DObject(appNode->nodeRef);
        if (importBboxes) {
          parentX3DObject.AddGeometry(L"Cube", L"MeshSurface", newAppNodeName,
                                      curveObj);
        }
        else {
          parentX3DObject.AddNurbsCurveList(CNurbsCurveDataArray(), siSINurbs,
                                            newAppNodeName, curveObj);
        }
        nodeRef = curveObj.GetRef();

        if (!nodeRef.IsValid()) {
          ESS_LOG_ERROR("Could not create curve " << shapeObj.getFullName());
        }

        returnNode = SceneNodePtr(new SceneNodeXSI(nodeRef));
      }

      if (fileXformNode) {
        fileXformNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();
      }

      if (usePerModelTimeControls && fileXformNode) {
        createItemArgs[0] = setupTimeControl(
            fileXformNode,
            findTimeControlDccIdentifier(fileXformNode, importRootNode,
                                         jobParams.xformTypes));
      }
      else {
        createItemArgs[0] = setupTimeControl(fileXformNode, importRootNode);
      }

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef,
                                 filename, shapeFullName, attachToExisting,
                                 createItemArgs);

      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef,
                                 filename, shapeFullName, attachToExisting,
                                 createItemArgs);

      // load curve topo if it's not hair because that will already have desired
      // topology if it exists
      if (!importBboxes && !curveObj.GetType().IsEqualNoCase(L"hair")) {
        alembic_create_item_Invoke(L"alembic_crvlist_topo", importRootNode,
                                   nodeRef, filename, shapeFullName,
                                   attachToExisting, createItemArgs);
      }

      // allow stretching as there may have been dynamics applied to the hair
      if (curveObj.GetType().IsEqualNoCase(L"hair")) {
        curveObj.GetActivePrimitive().PutParameterValue(L"AllowStretch", true);
      }

      // let's setup the xform op
      if (fileXformNode) {
        alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef,
                                   filename, xformFullName, attachToExisting,
                                   createItemArgs);
      }

      // load curve anim
      CRef returnOpRef;
      if (importBboxes) {
        CValue returnedOpVal;
        alembic_create_item_Invoke(L"alembic_bbox", importRootNode, nodeRef,
                                   filename, shapeFullName, attachToExisting,
                                   createItemArgs, returnedOpVal);
        returnOpRef = (CRef)returnedOpVal;
      }
      else {
        CValue returnedOpVal;
        alembic_create_item_Invoke(L"alembic_crvlist", importRootNode, nodeRef,
                                   filename, shapeFullName, attachToExisting,
                                   createItemArgs, returnedOpVal);
        returnOpRef = (CRef)returnedOpVal;
      }

      // load standin property
      if (importStandins && returnOpRef.IsValid()) {
        alembic_create_item_Invoke(L"alembic_standin", importRootNode,
                                   returnOpRef, filename, shapeFullName,
                                   attachToExisting, createItemArgs);
      }
    }
  }
  else if (AbcG::IPoints::matches(shapeObj.getMetaData())) {
    // ESS_LOG_WARNING("Import IPoints");
    AbcG::IPoints pointsIObject(shapeObj, Abc::kWrapExisting);
    AbcG::IPointsSchema pointsSchema = pointsIObject.getSchema();
    AbcG::IPointsSchema::Sample pointsSample = pointsSchema.getValue();

    CRef nodeRef;
    if (attachToExisting) {
      ESS_PROFILE_SCOPE("attachToExisting");
      nodeRef = appNode->nodeRef;

      if (!validate(nodeRef, CString("pointcloud"), shapeObj)) {
        return false;
      }

      returnNode = fileShapeNode;

      if (fileXformNode) {
        fileXformNode->setAttached(true);
      }
      fileShapeNode->setAttached(true);
    }
    else {
      X3DObject parentX3DObject(appNode->nodeRef);
      X3DObject pointsObj;
      if (importBboxes) {
        parentX3DObject.AddGeometry(L"Cube", L"MeshSurface", newAppNodeName,
                                    pointsObj);
      }
      else {
        parentX3DObject.AddPrimitive(L"PointCloud", newAppNodeName, pointsObj);
      }
      nodeRef = pointsObj.GetRef();

      if (!nodeRef.IsValid()) {
        ESS_LOG_ERROR("Could not create points " << shapeObj.getFullName());
      }

      returnNode = SceneNodePtr(new SceneNodeXSI(nodeRef));
    }

    if (fileXformNode) {
      fileXformNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();
    }

    if (usePerModelTimeControls && fileXformNode) {
      createItemArgs[0] = setupTimeControl(
          fileXformNode,
          findTimeControlDccIdentifier(fileXformNode, importRootNode,
                                       jobParams.xformTypes));
    }
    else {
      createItemArgs[0] = setupTimeControl(fileXformNode, importRootNode);
    }

    // load metadata
    alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef,
                               filename, shapeFullName, attachToExisting,
                               createItemArgs);

    // load visibility
    alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef,
                               filename, shapeFullName, attachToExisting,
                               createItemArgs);

    // let's setup the xform op
    if (fileXformNode) {
      alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef,
                                 filename, xformFullName, attachToExisting,
                                 createItemArgs);
    }

    // apply the ice tree
    CRef returnOpRef;
    if (importBboxes) {
      CValue returnedOpVal;
      alembic_create_item_Invoke(L"alembic_bbox", importRootNode, nodeRef,
                                 filename, shapeFullName, attachToExisting,
                                 createItemArgs, returnedOpVal);
      returnOpRef = (CRef)returnedOpVal;
    }
    else {
      CValue returnedOpVal;
      alembic_create_item_Invoke(L"alembic_points", importRootNode, nodeRef,
                                 filename, shapeFullName, attachToExisting,
                                 createItemArgs, returnedOpVal);
      returnOpRef = (CRef)returnedOpVal;
    }

    // load standin property
    if (importStandins && returnOpRef.IsValid()) {
      alembic_create_item_Invoke(L"alembic_standin", importRootNode,
                                 returnOpRef, filename, shapeFullName,
                                 attachToExisting, createItemArgs);
    }
  }
  else {
    std::stringstream s;
    s << "Unsupported Alembic type: " << shapeObj.getFullName().c_str();
    if (failOnUnsupported) {
      ESS_LOG_ERROR(s.str().c_str());
      return false;
    }
    ESS_LOG_WARNING(s.str().c_str());
  }

  return true;
}

bool createNodes(SceneNodeXSI* const appNode, SceneNodeAlembicPtr fileNode,
                 const IJobStringParser& jobParams, SceneNodePtr& returnNode,
                 bool bAttachToExisting)
{
  if (fileNode->type == SceneNode::ETRANSFORM) {  // we have a transform with
    // only one shape node child,
    // so we can merge

    SceneNodeAlembicPtr shapeNode;
    for (SceneChildIterator it = fileNode->children.begin();
         it != fileNode->children.end(); it++) {
      if (isShapeNode((*it)->type)) {
        shapeNode = reinterpret<SceneNode, SceneNodeAlembic>(*it);
        break;
      }
    }
    if (shapeNode) {
      return createMergeableNode(appNode, fileNode, shapeNode, jobParams,
                                 returnNode, bAttachToExisting);
    }
    else {
      ESS_LOG_ERROR("Could not find shape node.");
      return false;
    }
  }
  else if (fileNode->type == SceneNode::ITRANSFORM) {  // null nodes
    return createNode(appNode, fileNode, jobParams, returnNode,
                      bAttachToExisting);
  }
  // this shape node has the same parent transform as one or more other shape
  // nodes
  SceneNodeAlembicPtr xformNode;
  return createMergeableNode(appNode, xformNode, fileNode, jobParams,
                             returnNode, bAttachToExisting);
}

struct ImportStackElement {
  SceneNodePtr sceneNode;
  CRef parentNode;

  ImportStackElement(SceneNodePtr node) : sceneNode(node) {}
  ImportStackElement(SceneNodePtr node, CRef parent)
      : sceneNode(node), parentNode(parent)
  {
  }
};

ESS_CALLBACK_START(alembic_import_Execute, CRef&)

Context ctxt(in_ctxt);
CValueArray args = ctxt.GetAttribute(L"Arguments");

// inspect it
CValueArray importJobArgs(1);
CValue importJobResult;

// CString filename = args[0];
// bool importNormals = (bool)args[1];
// bool importUVs = (bool)args[2];
// bool importClusters = (bool)args[3];
// bool importVisibility = (bool)args[4];
// bool importStandins = (bool)args[5];
// bool importBboxes = (bool)args[6];
// bool attachToExisting = (bool)args[7];
// bool failOnUnsupported = (bool)args[8];
// CString identifierListStr = args[9].GetAsText();

std::stringstream sstream;

if (args.GetCount() != 10) {
  ESS_LOG_ERROR(
      "The alembic_import command requires 10 arguments, encountered only "
      << args.GetCount() << " arguments.");
  return CStatus(CStatus::InvalidArgument);
}

if (!args[0].GetAsText().IsEmpty()) {
  sstream << "filename=" << args[0].GetAsText().GetAsciiString() << ";";
}
sstream << "normals=" << (LONG)args[1] << ";uvs=" << (LONG)args[2]
        << ";facesets=" << (LONG)args[3]
        << ";importVisibilityControllers=" << (LONG)args[4];
sstream << ";importStandinProperties=" << (LONG)args[5]
        << ";importBoundingBoxes=" << (LONG)args[6]
        << ";attachToExisting=" << (LONG)args[7];
sstream << ";failOnUnsupported=" << (LONG)args[8];
if (!args[9].GetAsText().IsEmpty()) {
  sstream << ";identifiers=";
  sstream << args[9].GetAsText().GetAsciiString();
}

ESS_LOG_WARNING(
    "The alembic_import command is deprecated. Please use alembic_import_jobs "
    "instead.");

importJobArgs[0] = CString(sstream.str().c_str());
return Application().ExecuteCommand(L"alembic_import_jobs", importJobArgs,
                                    importJobResult);

ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_import_jobs_Execute, CRef&)
Context ctxt(in_ctxt);
CValueArray args = ctxt.GetAttribute(L"Arguments");

IJobStringParser jobParser;
std::string jobString = args[0].GetAsText().GetAsciiString();

if (jobString.empty()) {
  // let's setup the property
  CustomProperty settings;
  settings = Application().GetActiveSceneRoot().AddProperty(
      L"alembic_import_settings");

  // inspect it
  CValueArray inspectArgs(5);
  CValue inspectResult;
  inspectArgs[0] = settings.GetFullName();
  inspectArgs[1] = L"";
  inspectArgs[2] = L"Import Settings";
  inspectArgs[3] = siModal;
  inspectArgs[4] = false;
  Application().ExecuteCommand(L"InspectObj", inspectArgs, inspectResult);

  // prepare for deletion
  inspectArgs.Resize(1);
  inspectArgs[0] = settings.GetFullName();
  if ((bool)inspectResult) {
    Application().ExecuteCommand(L"DeleteObj", inspectArgs, inspectResult);
    return CStatus::Abort;
  }

  // retrieve the options
  jobParser.importNormals = settings.GetParameterValue(L"normals");
  jobParser.importUVs = settings.GetParameterValue(L"uvs");
  jobParser.importFacesets = settings.GetParameterValue(L"facesets");
  jobParser.importVisibilityControllers =
      (bool)settings.GetParameterValue(L"visibility");
  jobParser.importTransformControllers =
      (bool)settings.GetParameterValue(L"transforms");
  if (hasStandinSupport()) {
    LONG standinsValue = settings.GetParameterValue(L"standins");
    jobParser.importStandinProperties = standinsValue > 0;
    jobParser.importBoundingBoxes = standinsValue == 2;
  }
  else {
    jobParser.importStandinProperties = false;
    jobParser.importStandinProperties = false;
  }
  // jobParser.attachToExisting = settings.GetParameterValue(L"attach");
  jobParser.failOnUnsupported =
      settings.GetParameterValue(L"failOnUnsupported");
  jobParser.skipUnattachedNodes =
      settings.GetParameterValue(L"skipUnattachedNodes");
  jobParser.replacer = SearchReplace::createReplacer();
  jobParser.enableImportRootSelection =
      settings.GetParameterValue(L"enableImportRootSelection");
  jobParser.stripMayaNamespaces =
      settings.GetParameterValue(L"stripNamespaces");
  jobParser.importCurvesAsStrands =
      settings.GetParameterValue(L"importCurvesAsStrands");
  jobParser.useMultiFile = settings.GetParameterValue(L"multifile");
  jobParser.enableSubD = settings.GetParameterValue(L"enableSubD");
  jobParser.operatorCreationForExistingNodes =
      settings.GetParameterValue(L"operatorCreationForExistingNodes");

  int val = settings.GetParameterValue(L"defaultXformNode");
  if (val == 0) {
    jobParser.xformTypes = XSI_XformTypes::XMODEL;
  }
  else if (val == 1) {
    jobParser.xformTypes = XSI_XformTypes::XNULL;
  }

  val = settings.GetParameterValue(L"sceneMergeMethod");
  if (val == 0) {
    jobParser.extraParameters["sceneMergeMethod"] = "new";
  }
  else if (val == 1) {
    jobParser.extraParameters["sceneMergeMethod"] = "attach";
  }
  else if (val == 2) {
    jobParser.extraParameters["sceneMergeMethod"] = "attachAndNew";
  }

  val = settings.GetParameterValue(L"timeControlPlacement");
  if (val == 0) {
    jobParser.timeControl = timeControlOptions::SCENE_ROOT;
  }
  else if (val == 1) {
    jobParser.timeControl = timeControlOptions::ROOT_MODELS;
  }

  if (settings.GetParameterValue(L"fitTimeRange")) {
    jobParser.setParam("fitTimeRange");
  }

  std::stringstream versionInfo;
  versionInfo << "Exocortex Crate " << PLUGIN_MAJOR_VERSION << "."
              << PLUGIN_MINOR_VERSION << "." << crate_BUILD_VERSION;
  Application().LogMessage(versionInfo.str().c_str());
  Application().LogMessage(CString(L"[ExocortexAlembic] Using ReadJob:") +
                           jobParser.buildJobString().c_str());

  Application().ExecuteCommand(L"DeleteObj", inspectArgs, inspectResult);
}
else {
  bool bParseSuccess = jobParser.parse(jobString);
  if (!bParseSuccess) {
    ESS_LOG_ERROR("[alembic] Error parsing import job string.");
    return CStatus::Abort;
  }
  Application().LogMessage(CString(L"[ExocortexAlembic] Using ReadJob:") +
                           jobString.c_str());

  if (jobParser.extraParameters["sceneMergeMethod"] == "new" &&
      jobParser.attachToExisting) {  // backwards compatibility with
    // "attachToExisting" bool
    jobParser.extraParameters["sceneMergeMethod"] = "attach";
  }
}

// take care of the filename
if (jobParser.filename.empty()) {
  // let's see if we are in interactive mode
  if (Application().IsInteractive()) {
    CComAPIHandler toolkit;
    toolkit.CreateInstance(L"XSI.UIToolkit");
    CComAPIHandler filebrowser(toolkit.GetProperty(L"FileBrowser"));
    filebrowser.PutProperty(L"InitialDirectory",
                            Application().GetActiveProject().GetPath());
    filebrowser.PutProperty(L"Filter", L"Alembic Files(*.abc)|*.abc||");
    CValue returnVal;
    filebrowser.Call(L"ShowOpen", returnVal);
    jobParser.filename =
        filebrowser.GetProperty(L"FilePathName").GetAsText().GetAsciiString();
    if (jobParser.filename.empty()) {
      return CStatus::Abort;
    }
  }
  else {
    Application().LogMessage(L"[ExocortexAlembic] No filename specified.",
                             siErrorMsg);
    return CStatus::InvalidArgument;
  }
}

{
  ESS_PROFILE_SCOPE("alembic_import_jobs_Execute - without UI Dialog");

  // let's try to read this
  Abc::IArchive* archive = NULL;
  try {
    archive = getArchiveFromID(jobParser.filename);
  }
  catch (Alembic::Util::Exception& e) {
    std::string exc(e.what());
    ESS_LOG_ERROR("[alembic] Error reading file: " << e.what());
    return CStatus::Fail;
  }
  catch (...) {
    ESS_LOG_ERROR("[alembic] Error reading file: " << jobParser.filename
                                                   << " (uncaught exception)");
    return CStatus::Fail;
  }
  if (archive == NULL) {
    ESS_LOG_ERROR("[alembic] Error reading file: "
                  << jobParser.filename << " (NULL alembic pointer)");
    return CStatus::Fail;
  }

  addRefArchive(jobParser.filename);
  AbcArchiveCache* pArchiveCache = getArchiveCache(jobParser.filename);

  CString filenameCStr(jobParser.filename.c_str());

  // also precap the jobParser.filename with the project token just in case
  CString projectPath = Application().GetActiveProject().GetPath();
  for (ULONG i = 0; i < filenameCStr.Length(); i++) {
    if (filenameCStr.GetAt(i) == '\\')
      filenameCStr = filenameCStr.GetSubString(0, i) + L"/" +
                     filenameCStr.GetSubString(i + 1, 10000);
  }
  for (ULONG i = 0; i < projectPath.Length(); i++) {
    if (projectPath.GetAt(i) == '\\')
      projectPath = projectPath.GetSubString(0, i) + L"/" +
                    projectPath.GetSubString(i + 1, 10000);
  }
  if (filenameCStr.GetSubString(0, projectPath.Length()) == projectPath) {
    filenameCStr = L"[project path]" +
                   filenameCStr.GetSubString(projectPath.Length(), 10000);
  }

  CRef importRootNode = Application().GetActiveSceneRoot().GetRef();

  if (jobParser.extraParameters.find("importRoot") !=
      jobParser.extraParameters.end()) {
    CRef rootNode;
    rootNode.Set(jobParser.extraParameters["importRoot"].c_str());
    if (rootNode.IsValid()) {
      importRootNode = rootNode;
    }
    else {
      ESS_LOG_WARNING("importRoot is not valid. Using Scene_Root instead.");
    }
  }
  else if (jobParser.enableImportRootSelection) {
    CRefArray selectedObjects = Application().GetSelection().GetArray();
    if (selectedObjects.GetCount() > 1) {
      Application().LogMessage(
          L"[ExocortexAlembic] Too many objects selected, you can select at "
          L"most one import root.",
          siErrorMsg);
      return CStatus::InvalidArgument;
    }

    if (selectedObjects.GetCount() == 1) {
      importRootNode = selectedObjects[0];
      // importRootNode = X3DObject( importRootNode
      // ).GetParent3DObject().GetRef();
      importRootNode = X3DObject(importRootNode).GetRef();
      ESS_LOG_WARNING("Attachment root is "
                      << importRootNode.GetAsText().GetAsciiString());
    }
  }
  jobParser.extraParameters["appRootPath"] =
      importRootNode.GetAsText().GetAsciiString();

  AbcG::IObject root = archive->getTop();

  AbcObjectCache* pRootObjectCache = &(pArchiveCache->find("/")->second);

  jobParser.replaceColonsWithUnderscores = true;
  int nNumNodes = 0;
  SceneNodeAlembicPtr fileRoot = buildAlembicSceneGraph(
      pArchiveCache, pRootObjectCache, nNumNodes, jobParser, false);

  fileRoot->dccIdentifier =
      Application().GetActiveSceneRoot().GetRef().GetAsText().GetAsciiString();

  if (!jobParser.selectShapes) {
    ESS_LOG_WARNING(
        "Only selecting transform nodes (shape selection disabled)");
  }

  bool bImportAllNodes = true;

  if (jobParser.nodesToImport.size() > 0) {
    std::map<std::string, bool> selectionMap;

    for (int i = 0; i < jobParser.nodesToImport.size(); i++) {
      selectionMap[jobParser.nodesToImport[i]] = true;
    }

    // Note: the ImportScene and AttachToScene methods assume that parents of
    // each selected node are also selected
    int numSelected =
        selectNodes(fileRoot, selectionMap, true /*select parents*/,
                    false /*select children*/,
                    jobParser.selectShapes /*select shape nodes*/);

    if (numSelected < jobParser.nodesToImport.size()) {
      ESS_LOG_WARNING("Unabled find all filter nodes specified.");
    }

    if (numSelected > 0) {
      nNumNodes = numSelected;
      bImportAllNodes = false;
    }
  }
  else if (!jobParser.selectShapes) {
    int numSelected = selectTransformNodes(fileRoot);
    if (numSelected > 0) {
      nNumNodes = numSelected;
      bImportAllNodes = false;
    }
  }

  // ImportScene and AttachScene assume unselected nodes have been removed from
  // the alembic file scene graph
  if (!bImportAllNodes) {
    removeUnselectedNodes(fileRoot);
  }

  // printSceneGraph(fileRoot, false);

  // return CStatus::Fail;

  // clear the imported names!
  // nameMapClear();
  CString transformCacheModelName;
  Model transformCacheModel;

  // clear all alembic user data
  alembic_UD::clearAll();

  // return CStatus::Fail;

  if (jobParser.paramIsSet("fitTimeRange")) {
    size_t oMinSample = (size_t)-1, oMaxSample = 0;
    double oMinTime = DBL_MIN, oMaxTime = -DBL_MAX;
    GetSampleRange(fileRoot, oMinSample, oMaxSample, oMinTime, oMaxTime);
    // ESS_LOG_WARNING("time range: "<<oMinTime<<" "<<oMaxTime);

    if (oMaxSample > 1) {
      Application app;
      Project prj = app.GetActiveProject();

      // The PlayControl property set is stored with scene data under the
      // project
      CRefArray proplist = prj.GetProperties();
      Property playctrl(proplist.GetItem(L"Play Control"));

      double fps = playctrl.GetParameterValue(L"Rate");

      // ESS_LOG_WARNING("fps: "<<fps);

      playctrl.PutParameterValue(L"Out", (LONG)ceil(oMaxTime * fps));
    }
  }

  std::list<SceneNodeAppPtr> newNodes;

  if (jobParser.extraParameters["sceneMergeMethod"] ==
      "attach") {  // if(jobParser.attachToExisting)
    nNumNodes = 0;
    SceneNodeXSIPtr appRoot =
        buildCommonSceneGraph(importRootNode, nNumNodes, false, false);

    // printSceneGraph(fileRoot, true);
    // printSceneGraph(appRoot, true);

    XSIProgressBar progBar;
    progBar.init(nNumNodes);

    bool bAttachSuccess =
        AttachSceneFile(fileRoot, appRoot, jobParser, &progBar, &newNodes);

    if (!bAttachSuccess) {
      return CStatus::Fail;
    }
  }
  else if (jobParser.extraParameters["sceneMergeMethod"] == "attachAndNew") {
    nNumNodes = 0;
    SceneNodeXSIPtr appRoot =
        buildCommonSceneGraph(importRootNode, nNumNodes, false, false);

    // printSceneGraph(fileRoot, true);
    // printSceneGraph(appRoot, true);

    XSIProgressBar progBar;
    progBar.init(nNumNodes);

    bool bAttachSuccess =
        MergeSceneFile(fileRoot, appRoot, jobParser, &progBar, &newNodes);

    if (!bAttachSuccess) {
      return CStatus::Fail;
    }
  }
  else {
    // should build a full scene graph when start doing name checking
    SceneNodeXSIPtr appRoot(new SceneNodeXSI(importRootNode));

    // printSceneGraph(fileRoot, false);

    XSIProgressBar progBar;
    progBar.init(nNumNodes);

    bool bImportSuccess =
        ImportSceneFile(fileRoot, appRoot, jobParser, &progBar, &newNodes);

    if (!bImportSuccess) {
      return CStatus::Fail;
    }
  }

  CValueArray vals;
  for (std::list<SceneNodeAppPtr>::iterator it = newNodes.begin();
       it != newNodes.end(); it++) {
    SceneNodeXSIPtr appNode = reinterpret<SceneNodeApp, SceneNodeXSI>(*it);

    // X3DObject xObj(appNode->nodeRef);

    ////ESS_LOG_WARNING("name: "<<fullname.GetAsciiString());
    ////CString fullname = xObj.GetFullName();

    // CString name = xObj.GetName();
    // CString modelname = xObj.GetModel().GetName();
    // vals.Add(modelname+"."+name);

    // vals.Add(xObj);

    vals.Add(appNode->nodeRef);
  }

  CValue returnVal(vals);
  ctxt.PutAttribute(L"ReturnValue", returnVal);

  delRefArchive(jobParser.filename);
}

return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_import_settings_Define, CRef&)
Context ctxt(in_ctxt);
CustomProperty oCustomProperty;
Parameter oParam;
oCustomProperty = ctxt.GetSource();

// get the current frame in an out
oCustomProperty.AddParameter(L"normals", CValue::siBool, siPersistable, L"",
                             L"", 0, 0, 1, 0, 1, oParam);
oCustomProperty.AddParameter(L"uvs", CValue::siBool, siPersistable, L"", L"", 1,
                             0, 1, 0, 1, oParam);
oCustomProperty.AddParameter(L"facesets", CValue::siBool, siPersistable, L"",
                             L"", 1, 0, 1, 0, 1, oParam);
oCustomProperty.AddParameter(L"visibility", CValue::siInt4, siPersistable, L"",
                             L"", 0, 0, 10, 0, 10, oParam);
oCustomProperty.AddParameter(L"transforms", CValue::siInt4, siPersistable, L"",
                             L"", 0, 0, 10, 0, 10, oParam);
if (hasStandinSupport()) {
  oCustomProperty.AddParameter(L"standins", CValue::siInt4, siPersistable, L"",
                               L"", 0, 0, 10, 0, 10, oParam);
}
// oCustomProperty.AddParameter(L"attach",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
oCustomProperty.AddParameter(L"sceneMergeMethod", CValue::siInt4, siPersistable,
                             L"", L"", 0, 0, 5, 0, 5, oParam);
oCustomProperty.AddParameter(L"skipUnattachedNodes", CValue::siBool,
                             siPersistable, L"", L"", 0, 0, 1, 0, 1, oParam);
oCustomProperty.AddParameter(L"failOnUnsupported", CValue::siBool,
                             siPersistable, L"", L"", 0, 0, 1, 0, 1, oParam);
oCustomProperty.AddParameter(L"enableImportRootSelection", CValue::siBool,
                             siPersistable, L"", L"", 0, 0, 1, 0, 0, oParam);
oCustomProperty.AddParameter(L"stripNamespaces", CValue::siBool, siPersistable,
                             L"", L"", 0, 0, 1, 0, 0, oParam);
oCustomProperty.AddParameter(L"importCurvesAsStrands", CValue::siBool,
                             siPersistable, L"", L"", 0, 0, 1, 0, 0, oParam);
oCustomProperty.AddParameter(L"fitTimeRange", CValue::siBool, siPersistable,
                             L"", L"", 0, 0, 1, 0, 0, oParam);
oCustomProperty.AddParameter(L"multifile", CValue::siBool, siPersistable, L"",
                             L"", 0, 0, 1, 0, 0, oParam);
oCustomProperty.AddParameter(L"enableSubD", CValue::siBool, siPersistable, L"",
                             L"", 1, 0, 1, 0, 0, oParam);
oCustomProperty.AddParameter(L"defaultXformNode", CValue::siInt4, siPersistable,
                             L"", L"", 0, 0, 5, 0, 5, oParam);
oCustomProperty.AddParameter(L"timeControlPlacement", CValue::siInt4,
                             siPersistable, L"", L"", 0, 0, 5, 0, 5, oParam);
oCustomProperty.AddParameter(L"operatorCreationForExistingNodes",
                             CValue::siBool, siPersistable, L"", L"", 1, 0, 1,
                             0, 0, oParam);

return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_import_settings_DefineLayout, CRef&)
Context ctxt(in_ctxt);
PPGLayout oLayout;
PPGItem oItem;
oLayout = ctxt.GetSource();
oLayout.Clear();

oLayout.SetViewSize(600, 600);

std::stringstream versionText;
versionText << "Exocortex Crate " << PLUGIN_MAJOR_VERSION << "."
            << PLUGIN_MINOR_VERSION << "." << crate_BUILD_VERSION;
oLayout.AddStaticText(versionText.str().c_str());

oLayout.AddGroup(L"Geometry");
oLayout.AddItem(L"normals", L"Normals");
oLayout.AddItem(L"uvs", L"UVs");
oLayout.AddItem(L"facesets", L"Clusters");

CValueArray items(4);
items[0] = L"Just Import Value if Constant";
items[1] = (LONG)0l;
items[2] = L"Connected Operators";
items[3] = (LONG)1l;
oLayout.AddEnumControl(L"visibility", items, L"Visibility");

items.Resize(4);
items[0] = L"Just Import Value if Constant";
items[1] = (LONG)0l;
items[2] = L"Connected Operators";
items[3] = (LONG)1l;
oLayout.AddEnumControl(L"transforms", items, L"Transforms");

if (hasStandinSupport()) {
  items.Resize(6);
  items[0] = L"No standins";
  items[1] = (LONG)0l;
  items[2] = L"Import data + standins";
  items[3] = (LONG)1l;
  items[4] = L"Standins as bboxes";
  items[5] = (LONG)2l;
  oLayout.AddEnumControl(L"standins", items, L"Standins");
}
// oLayout.AddItem(L"attach", L"Attach to existing objects");

items.Resize(6);
items[0] = L"New nodes";
items[1] = (LONG)0l;
items[2] = L"Attach to existing";
items[3] = (LONG)1l;
items[4] = L"Attach to existing + new nodes";
items[5] = (LONG)2l;
oLayout.AddEnumControl(L"sceneMergeMethod", items, L"Scene Merge Method");

oLayout.AddItem(L"skipUnattachedNodes", L"Skip nodes that fail to attach");
oLayout.AddItem(L"failOnUnsupported", L"Fail upon unsupported alembic types");
oLayout.AddItem(L"enableImportRootSelection", L"Import Root Selection");
oLayout.AddItem(L"stripNamespaces", L"Strip Namespaces");
oLayout.AddItem(L"importCurvesAsStrands", L"Import Curves as Strands");
oLayout.AddItem(L"fitTimeRange", L"Fit Time Range");
oLayout.AddItem(L"multifile", L"Multifile");
oLayout.AddItem(L"enableSubD", L"Subdivision Surfaces");
oLayout.AddItem(L"operatorCreationForExistingNodes",
                L"Operator Creation For Existing Nodes");

items.Resize(4);
items[0] = L"Model";
items[1] = (LONG)0l;
items[2] = L"Null";
items[3] = (LONG)1l;
oLayout.AddEnumControl(L"defaultXformNode", items, L"Default Xform Node");

items.Resize(4);
items[0] = L"Scene Root";
items[1] = (LONG)0l;
items[2] = L"Root Models";
items[3] = (LONG)1l;
oLayout.AddEnumControl(L"timeControlPlacement", items,
                       L"Time Control Placement");

oLayout.EndGroup();

return CStatus::OK;
ESS_CALLBACK_END
