// alembicPlugin
// Initial code generated by Softimage SDK Wizard
// Executed Fri Aug 19 09:14:49 UTC+0200 2011 by helge
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include "stdafx.h"
#include "arnoldHelpers.h" 

using namespace XSI; 
using namespace MATH; 

#include "AlembicLicensing.h"

#include "AlembicWriteJob.h"
#include "AlembicPoints.h"
#include "AlembicCurves.h"
#include "CommonProfiler.h"
#include "CommonMeshUtilities.h"
#include "CommonUtilities.h"
#include "CommonAbcCache.h"
#include "CommonImport.h"
#include "sceneGraph.h"


CString getTimeControlExpression(CString timeControlName)
{
   return timeControlName+L".current * "+timeControlName+L".factor + "+timeControlName+L".offset + "+timeControlName+L".frameOffset / PlayControl.Rate";
}



ESS_CALLBACK_START(alembic_import_Init,CRef&)
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"filename");
   oArgs.Add(L"normals");
   oArgs.Add(L"uvs");
   oArgs.Add(L"clusters");
   oArgs.Add(L"visibility");
   oArgs.Add(L"standins");
   oArgs.Add(L"bboxes");
   oArgs.Add(L"attach");
   oArgs.Add(L"failOnUnsupported");
   oArgs.Add(L"identifiers");
	return CStatus::OK;
ESS_CALLBACK_END


ESS_CALLBACK_START(alembic_import_jobs_Init,CRef&)

	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"importjobs");
	return CStatus::OK; 
ESS_CALLBACK_END


ESS_CALLBACK_START(alembic_create_item_Init,CRef&)
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"type");
   oArgs.Add(L"target");
   oArgs.Add(L"file");
   oArgs.Add(L"identifier");
   oArgs.Add(L"reattach");
   oArgs.Add(L"timecontrolprop");
   oArgs.Add(L"facesets");
   oArgs.Add(L"normals");
   oArgs.Add(L"uvs");
   oArgs.Add(L"bindpose");
	return CStatus::OK;
ESS_CALLBACK_END


enum alembicItemType{
   alembicItemType_xform,
   alembicItemType_camera,
   alembicItemType_polymesh_topo,
   alembicItemType_bbox,
   alembicItemType_polymesh,
   alembicItemType_crvlist_topo,
   alembicItemType_crvlist,
   alembicItemType_curves,
   alembicItemType_points,
   alembicItemType_metadata,
   alembicItemType_timecontrol,
   alembicItemType_visibility,
   alembicItemType_geomapprox,
   alembicItemType_standin,
   alembicItemType_nurbs,
   alembicItemType_none
};

std::map<std::string,alembicItemType> gItemTypeMap;

CStatus alembic_create_item_Invoke
(
   const CString & type,
   const CRef& importRootNode, 
   const CRef & target,
   const CString & file,
   const CString & identifier,
   bool attachToExisting,
   const CValueArray & args,
   CValue & returnVal
)
{
	ESS_PROFILE_SCOPE("alembic_create_item_Invoke");

	// fill the map in case it is empty
   if(gItemTypeMap.size() == 0)
   {
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_xform",alembicItemType_xform));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_camera",alembicItemType_camera));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_polymesh_topo",alembicItemType_polymesh_topo));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_bbox",alembicItemType_bbox));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_polymesh",alembicItemType_polymesh));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_crvlist_topo",alembicItemType_crvlist_topo));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_crvlist",alembicItemType_crvlist));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_curves",alembicItemType_curves));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_points",alembicItemType_points));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_metadata",alembicItemType_metadata));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_timecontrol",alembicItemType_timecontrol));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_visibility",alembicItemType_visibility));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_geomapprox",alembicItemType_geomapprox));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_standin",alembicItemType_standin));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_nurbs",alembicItemType_nurbs));
   }

   // query the item type from the map
   CString realType(type);
   realType.Lower();
   std::map<std::string,alembicItemType>::iterator it = gItemTypeMap.find(realType.GetAsciiString());
   alembicItemType itemType = alembicItemType_none;
   if(it != gItemTypeMap.end())
      itemType = it->second;

   // cast into the standard types
   X3DObject x3d(target);
   Primitive prim(target);

   bool bMultifile = args[5];

   // now let's find the real target for this
   CRef realTarget;
   { ESS_PROFILE_SCOPE("alembic_create_item_Invoke find_real_target");
   switch(itemType)
   {
      case alembicItemType_xform:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetKinematics().GetLocal().GetRef();
         else
         {
            KinematicState kine(target);
            if(kine.IsValid())
               realTarget = target;
            else
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         break;
      }
      case alembicItemType_visibility:
      case alembicItemType_geomapprox:
      {
         if(x3d.IsValid())
         {
            Property visProp;
            if(itemType == alembicItemType_visibility)
               x3d.GetPropertyFromName(L"Visibility",visProp);
            else
            {
               x3d.GetPropertyFromName(L"GeomApprox",visProp);
            }
            realTarget = visProp.GetRef();
         }
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         break;
      }
      case alembicItemType_camera:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetActivePrimitive().GetRef();
         else if(prim.IsValid())
            realTarget = prim.GetRef();
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         if(!Primitive(realTarget).GetType().IsEqualNoCase(L"camera"))
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         break;
      }
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_curves:
      case alembicItemType_points:
      case alembicItemType_nurbs:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetActivePrimitive().GetRef();
         else if(prim.IsValid())
            realTarget = prim.GetRef();
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         // now check the type as well
         if(itemType == alembicItemType_polymesh_topo || itemType == alembicItemType_polymesh)
         {
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"polymsh"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(itemType == alembicItemType_crvlist_topo || itemType == alembicItemType_crvlist)
         {
			CString type = Primitive(realTarget).GetType();
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"crvlist") && 
			   !Primitive(realTarget).GetType().IsEqualNoCase(L"pointcloud") &&
			   !Primitive(realTarget).GetType().IsEqualNoCase(L"hair"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(itemType == alembicItemType_points || itemType == alembicItemType_curves)
         {
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"pointcloud"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(itemType == alembicItemType_nurbs)
         {
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"surfmsh"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         break;
      }
      case alembicItemType_metadata:
      case alembicItemType_timecontrol:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetRef();
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         break;
      }
      case alembicItemType_standin:
      {
         CustomOperator alembicOp(target);
         ICETree alembicTree(target);
         if(!alembicOp.IsValid() && !alembicTree.IsValid())
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         if(!alembicOp.GetType().GetSubString(0,8).IsEqualNoCase(L"alembic_") && !alembicTree.GetName().GetSubString(0,4).IsEqualNoCase(L"abc_"))
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         if(alembicOp.IsValid())
            realTarget = alembicOp.GetRef();
         else
         {
            // loop for the first custom node
            CRefArray compounds = alembicTree.GetCompoundNodes();
            for(LONG j=0;j<compounds.GetCount();j++)
            {
               ICECompoundNode compound(compounds[j]);
               CRefArray nodes = compound.GetNodes();
               for(LONG k=0;k<nodes.GetCount();k++)
               {
                  CString nodeType = ICENode(nodes[k]).GetType();
                  if(nodeType.GetSubString(0,8).IsEqualNoCase(L"alembic_"))
                  {
                     realTarget = nodes[k];
                     break;
                  }
               }

               if(realTarget.IsValid())
                  break;
            }

            if(!realTarget.IsValid())
            {
               Application().LogMessage(L"[ExocortexAlembic] Could not find custom abc node on icetree '"+target.GetAsText()+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         break;
      }
      default:
      {
         Application().LogMessage(L"[ExocortexAlembic] Unknown item type '"+type+L"'.",siErrorMsg);
         return CStatus::InvalidArgument;
      }
   }
   }

   // now validate the identifier if necessary
   Abc::IObject abcObject;
   AbcObjectCache *pObjectCache = NULL;
   bool isAnimated = false;
   { ESS_PROFILE_SCOPE("alembic_create_item_Invoke validate_the_identifier");
   switch(itemType)
   {
      case alembicItemType_xform:
      case alembicItemType_camera:
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_curves:
      case alembicItemType_metadata:
      case alembicItemType_points:
      case alembicItemType_geomapprox:
      case alembicItemType_nurbs:
      {
        pObjectCache = getObjectCacheFromArchive( std::string( file.GetAsciiString() ), std::string( identifier.GetAsciiString() ) );
         if(pObjectCache == NULL || !pObjectCache->obj.valid())
         {
           EC_LOG_ERROR("[ExocortexAlembic] Identifier '" << identifier.GetAsciiString() << "' is not valid for given filename: " << file.GetAsciiString() );
            return CStatus::InvalidArgument;
         }
         abcObject = pObjectCache->obj;
         isAnimated = (itemType == alembicItemType_bbox) || (! pObjectCache->isConstant && itemType != alembicItemType_geomapprox) || itemType == alembicItemType_points || bMultifile;
         break;
      }
      case alembicItemType_visibility:
      {
        pObjectCache = getObjectCacheFromArchive( std::string( file.GetAsciiString() ), std::string( identifier.GetAsciiString() ) );
         if(pObjectCache == NULL || !pObjectCache->obj.valid())
         {
           EC_LOG_ERROR("[ExocortexAlembic] Identifier '" << identifier.GetAsciiString() << "' is not valid for given filename: " << file.GetAsciiString() );
            return CStatus::InvalidArgument;
         }
         abcObject = pObjectCache->obj;
         AbcG::IVisibilityProperty visibilityProperty = getAbcVisibilityProperty(abcObject);
         if(!visibilityProperty.valid())
         {
            return CStatus::InvalidArgument;
         }
         isAnimated = visibilityProperty.getNumSamples() > 1;
         break;
      }
      case alembicItemType_standin:
      default:
         break;
   }
   }

    // check if we have a timecontrol in the args
    CustomProperty timeControlProp;
    CRef timeControlRef;
    if(args.GetCount() > 0)
       timeControlRef = args[0];
    timeControlProp = timeControlRef;
	CValue setExprReturn;
    CValueArray setExprArgs(2);  
	CString expressionString;
    if(timeControlProp.IsValid())
    {
       setExprArgs[1] = getTimeControlExpression(timeControlProp.GetFullName());
	   expressionString = getTimeControlExpression(timeControlProp.GetFullName());
    }

    //TODO: enable operator creation if "attach to existing" and user option are enabled

    bool operatorCreationForExistingOperators = args[6];
    bool bEnableOperatorCreation = true; 
    //if operator creation is disabled for this import, and we are doing a node update (attachToExisting is true for this node),
    //   then disable operator creation for this node
    if(!operatorCreationForExistingOperators){
       bEnableOperatorCreation = !attachToExisting;
    }

    { ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator");
   // now create an operator...?
   switch(itemType)
   {
      case alembicItemType_xform:
      case alembicItemType_visibility:
      case alembicItemType_geomapprox:
      case alembicItemType_camera:
      case alembicItemType_polymesh_topo://in this case, a normals operator and multiple UV operator may be created. Also, clusters may be created. 
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_nurbs:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_xxx");
		// for visibility, let's see if we should create an operator
         if(itemType == alembicItemType_visibility)
         {
            ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator visibility");
            bool importVis = args[4];
            if(!isAnimated && !importVis)
            {
               // this means skip the creation of the operator
               AbcG::IVisibilityProperty visibilityProperty = getAbcVisibilityProperty(abcObject);
               if(visibilityProperty.valid())
               {
                  int rawVisibilityValue = visibilityProperty.getValue ( size_t(0) );
                  AbcG::ObjectVisibility visibilityValue = AbcG::ObjectVisibility ( rawVisibilityValue );

                  Property prop(realTarget);
                  switch(visibilityValue)
                  {
                     case AbcG::kVisibilityVisible:
                     {
                        prop.PutParameterValue(L"viewvis",true);
                        prop.PutParameterValue(L"rendvis",true);
                        break;
                     }
                     case AbcG::kVisibilityHidden:
                     {
                        prop.PutParameterValue(L"viewvis",false);
                        prop.PutParameterValue(L"rendvis",false);
                        break;
                     }
                     default:
                     {
                        break;
                     }
                  }
                  break;
               }
            }
         }
         else if(itemType == alembicItemType_xform)
         {
			const bool importTransforms = args[7];
            if(!isAnimated && !importTransforms)  
            {
                ESS_PROFILE_SCOPE("alembic_create_itme_Invoke importConstantXform");

                CustomOperator op;
                if(attachToExisting)
                {
                   CRef opRef;
                   opRef.Set(realTarget.GetAsText()+L"."+realType);
                   op = opRef;
                }

                if(!op.IsValid())//if an operator already exists (attachToExisting), then update the operator instead
                {
                   KinematicState kineState(realTarget);

                   pObjectCache->getXform();
                   Abc::M44d matrix = pObjectCache->getXformMatrix(0);
                  
	               CMatrix4 xsiMatrix;
                   xsiMatrix.Set( 
                      matrix.getValue()[0],matrix.getValue()[1],matrix.getValue()[2],matrix.getValue()[3],
			          matrix.getValue()[4],matrix.getValue()[5],matrix.getValue()[6],matrix.getValue()[7],
			          matrix.getValue()[8],matrix.getValue()[9],matrix.getValue()[10],matrix.getValue()[11],
			          matrix.getValue()[12],matrix.getValue()[13],matrix.getValue()[14],matrix.getValue()[15]);
   	            
                   CTransformation xsiTransform;
	               xsiTransform.SetMatrix4(xsiMatrix);

                   kineState.PutTransform(xsiTransform);

                   break;
                }
            }
         }


         // for xform, disable softimage scaling
         if(itemType == alembicItemType_xform)
            KinematicState(realTarget).PutParameterValue(L"siscaling",false);

         CustomOperator op;
         if(attachToExisting)
         {
            CRef opRef;
            opRef.Set(realTarget.GetAsText()+L"."+realType);
            op = opRef;
         }

         if(!op.IsValid() && bEnableOperatorCreation)
         {
             
			 {
			   ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator CreateObject");
		       op = Application().GetFactory().CreateObject(realType);
			 }
			 { 
                ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator AddPorts");
                op.AddOutputPort(realTarget);
                op.AddInputPort(realTarget);
			 }
             

             // experimental operator creation code. It doesn't seem faster so far...
             //{
             //   ESS_PROFILE_SCOPE("alembic_create_item_Invoke AddCustomOp");
             //  CRefArray inputs(1);
             //  inputs[0] = realTarget;
             //  if(itemType == alembicItemType_xform){
             //     KinematicState targetObject(realTarget);
             //     op = targetObject.AddCustomOp( realType, inputs );
             //  }
             //  else{
             //     ProjectItem targetObject(realTarget);
             //     op = targetObject.AddCustomOp( realType, inputs );
             //  }
             //}

             siConstructionMode consMode = siConstructionModeModeling;
             if(itemType != alembicItemType_crvlist_topo && itemType != alembicItemType_polymesh_topo){
                consMode = siConstructionModeAnimation;
             }
			 { 
                ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator Connect");
				op.Connect(consMode);
			 }
         }

         if(op.IsValid()){//connect up the operator parameters

            op.PutParameterValue(L"path",file);
            op.PutParameterValue(L"identifier",identifier);
            if(bMultifile){
               op.PutParameterValue(L"multifile", true);
            }

            // if we are not a topo op, let's connect to the timecontrol
            bool receivesExpression = isAnimated;

            if(!bMultifile){
               ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator dynamic topo check");
               if(itemType == alembicItemType_crvlist_topo)
                  receivesExpression = false;
               else if(itemType == alembicItemType_polymesh_topo)
               {
                  // check if the compound has more than one sample on its facecounts
                  Abc::ICompoundProperty abcCompound = getCompoundFromObject(abcObject);
                  Abc::IInt32ArrayProperty faceCountProp = Abc::IInt32ArrayProperty(abcCompound,".faceCounts");
                  if(faceCountProp.valid())
                     receivesExpression = !faceCountProp.isConstant();
                  
			      if ( !receivesExpression ) // still false, check .faceIndices just in case and reuse faceCountProp variable!
			      {
				      faceCountProp = Abc::IInt32ArrayProperty(abcCompound,".faceIndices");
				      if (faceCountProp.valid())
					      receivesExpression = !faceCountProp.isConstant();
				      else
					      receivesExpression = false;
			      }
               }
            }

            if(receivesExpression)
            {
			    ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator receivesExpression");

               // check if we have a timecontrol in the args
                if(timeControlProp.IsValid())
               {
				    //setExprArgs[0] = op.GetFullName()+L".time";
				    op.GetParameter("time").AddExpression( expressionString );
				   //Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
               }
            }
         }

         // store the return value
         returnVal = op.GetRef();

         // if we are a polygon mesh topo op, oh dear
         if(itemType == alembicItemType_polymesh_topo && args.GetCount() > 3)
         {
			 ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo");

            bool importClusters = args[1];
            bool importNormals = args[2];
            bool importUvs = args[3];

            AbcG::IPolyMesh abcMesh;
            AbcG::ISubD abcSubD;
            if(AbcG::IPolyMesh::matches(abcObject.getMetaData()))
               abcMesh = AbcG::IPolyMesh(abcObject,Abc::kWrapExisting);
            else
               abcSubD = AbcG::ISubD(abcObject,Abc::kWrapExisting);
            if(!abcMesh.valid() && !abcSubD.valid())
               return CStatus::OK;

            PolygonMesh meshGeo = Primitive(realTarget).GetGeometry();
            //for our "apply" mode, I feel no changes our necessary here. It is hard to know what user intended.
            //Let them handle it via the option that already exists.
            if(importClusters)
            {
        	  ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo importClusters");
		       std::vector<std::string> faceSetNames;
               if(abcMesh.valid())
                  abcMesh.getSchema().getFaceSetNames(faceSetNames);
               else
                  abcSubD.getSchema().getFaceSetNames(faceSetNames);
               for(size_t j=0;j<faceSetNames.size();j++)
               {
                  if(attachToExisting)
                  {
                     if(meshGeo.GetClusters().GetItem(CString(faceSetNames[j].c_str())).IsValid()) //only create clusters that do not exist
                        continue;
                  }
                  AbcG::IFaceSetSchema faceSet;
                  if(abcMesh.valid())
                     faceSet = abcMesh.getSchema().getFaceSet(faceSetNames[j]).getSchema();
                  else
                     faceSet = abcSubD.getSchema().getFaceSet(faceSetNames[j]).getSchema();
                  AbcG::IFaceSetSchema::Sample faceSetSample = faceSet.getValue();
                  Abc::Int32ArraySamplePtr faces = faceSetSample.getFaces();
                  CLongArray elements((LONG)faces->size());
                  for(size_t k=0;k<faces->size();k++)
                     elements[(LONG)k] = (LONG)faces->get()[k];
                  Cluster cluster;
                  meshGeo.AddCluster(L"poly",CString(faceSetNames[j].c_str()),elements,cluster);
               }
            }

            if(importNormals && abcMesh.valid())
            {
              ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo importNormals");
		       AbcG::IN3fGeomParam meshNormalsParam = abcMesh.getSchema().getNormalsParam();
               if(meshNormalsParam.valid())
               {
                  Abc::N3fArraySamplePtr meshNormals = meshNormalsParam.getExpandedValue(0).getVals();

                  CRef clusterPropRef;
                  if(attachToExisting)
                     clusterPropRef.Set(realTarget.GetAsText()+L".cls.User_Normal_Cluster.User_Normal_Property");
                  if(!clusterPropRef.IsValid())
                  {
                     // create user normals
                     CValue createUserNormalReturnVal;
                     CValueArray createUserNormalArgs(1);
                     createUserNormalArgs[0] = Primitive(realTarget).GetParent3DObject().GetFullName();
                     Application().ExecuteCommand(L"CreateUserNormals",createUserNormalArgs,createUserNormalReturnVal);
                  }
                  ClusterProperty userNormalProp;
                  CRefArray clusters = meshGeo.GetClusters();
                  for(LONG j=0;j<clusters.GetCount();j++)
                  {
                     Cluster cluster(clusters[j]);
                     if(!cluster.GetType().IsEqualNoCase(L"sample"))
                        continue;
                     CRefArray props(cluster.GetLocalProperties());
                     for(LONG k=0;k<props.GetCount();k++)
                     {
                        ClusterProperty prop(props[k]);
                        if(prop.GetType().IsEqualNoCase(L"normal"))
                        {
                           userNormalProp = props[k];
                           break;
                        }
                     }
                     if(userNormalProp.IsValid())
                        break;
                  }
                  if(userNormalProp.IsValid())
                  {
                     // we found it, and we need to attach the op
                     CustomOperator op;
                     if(attachToExisting)
                     {
                        CRef opRef;
                        opRef.Set(userNormalProp.GetFullName()+L".alembic_normals");
                        op = opRef;
                     }
                     if(!op.IsValid() && bEnableOperatorCreation)
                     {
                        op = Application().GetFactory().CreateObject(L"alembic_normals");
                        op.AddOutputPort(userNormalProp.GetRef());
                        op.AddInputPort(userNormalProp.GetRef());
                        op.AddInputPort(realTarget);
                        op.Connect();
                     }

                     if(!op.IsValid()){
                        op.PutParameterValue(L"path",file);
                        op.PutParameterValue(L"identifier",identifier);
                        if(bMultifile){
                           op.PutParameterValue(L"multifile", true);
                        }
                        if(!timeControlProp.IsValid())
                        {
                           CRef timeControlRef;
                           if(args.GetCount() > 0)
                              timeControlRef = args[0];
                           timeControlProp = timeControlRef;
                        }
                        if(timeControlProp.IsValid())// Shouldn't we not connect time if normals are constant (we would have faster viewport speeds)
                        {
                           CValue setExprReturn;
                           CValueArray setExprArgs(2);
                           setExprArgs[0] = op.GetFullName()+L".time";
                           setExprArgs[1] = getTimeControlExpression(timeControlProp.GetFullName());
                           Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
                        }
                     }
                  }
               }
            }
            if(importUvs)
            {
                ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo importUvs");
				AbcG::IV2fGeomParam meshUVsParam;
               if(abcMesh.valid())
                  meshUVsParam = abcMesh.getSchema().getUVsParam();
               else
                  meshUVsParam = abcSubD.getSchema().getUVsParam();
               if(meshUVsParam.valid())
               {
                 // check if we have a uv set names prop
                 CStringArray uvSetNames;
                 if(abcMesh.valid())
                 {
                    if ( abcMesh.getSchema().getPropertyHeader( ".uvSetNames" ) != NULL )
                    {
                       Abc::IStringArrayProperty uvSetNamesProp = Abc::IStringArrayProperty( abcMesh.getSchema(), ".uvSetNames" );
                       Abc::StringArraySamplePtr ptr = uvSetNamesProp.getValue(0);
                       for(size_t i=0;i<ptr->size();i++)
                          uvSetNames.Add(CString(ptr->get()[i].c_str()));
                    }
                 }
                 else
                 {
                    if ( abcSubD.getSchema().getPropertyHeader( ".uvSetNames" ) != NULL )
                    {
                       Abc::IStringArrayProperty uvSetNamesProp = Abc::IStringArrayProperty( abcSubD.getSchema(), ".uvSetNames" );
                       Abc::StringArraySamplePtr ptr = uvSetNamesProp.getValue(0);
                       for(size_t i=0;i<ptr->size();i++)
                          uvSetNames.Add(CString(ptr->get()[i].c_str()));
                    }
                 }
                 if(uvSetNames.GetCount() == 0)
                    uvSetNames.Add(L"Texture_Projection");

                 // for each uv set name
                 for(LONG uvI=0; uvI < uvSetNames.GetCount(); uvI++)
                 {
                    CRef clusterPropRef;
                    if(attachToExisting)
                       clusterPropRef.Set(realTarget.GetAsText()+L".cls.Texture_Coordinates_AUTO."+uvSetNames[uvI]);
                    if(!clusterPropRef.IsValid())
                    {
                       CLongArray in_indices;
                       Cluster io_cluster;
                       CStatus status = Primitive(realTarget).GetParent3DObject().GetActivePrimitive().GetGeometry().AddCluster(L"sample", L"Texture_Coordinates_AUTO", in_indices, io_cluster);
                       io_cluster.AddProperty("Texture Projection", false, uvSetNames[uvI]);

                    //   CValue createProjectionReturnVal;
                    //   CValueArray createProjectionArgs(5);
                    //   createProjectionArgs[0] = Primitive(realTarget).GetParent3DObject().GetFullName();
                    //   createProjectionArgs[1] = siTxtUV;
                    //   createProjectionArgs[2] = siTxtDefaultPlanarXY;
                    //   createProjectionArgs[3] = L"";
                    //   createProjectionArgs[4] = uvSetNames[uvI];
                    //   Application().ExecuteCommand(L"CreateProjection",createProjectionArgs,createProjectionReturnVal);
                    }

                    ClusterProperty uvProp;
                    CRefArray clusters = meshGeo.GetClusters();
                    for(LONG j=0;j<clusters.GetCount();j++)
                    {
                       Cluster cluster(clusters[j]);
                       if(!cluster.GetType().IsEqualNoCase(L"sample"))
                          continue;
                       CRefArray props(cluster.GetLocalProperties());
                       for(LONG k=0;k<props.GetCount();k++)
                       {
                          ClusterProperty prop(props[k]);
                          if(prop.GetType().IsEqualNoCase(L"uvspace") && prop.GetName().IsEqualNoCase(uvSetNames[uvI]))
                          {
                             uvProp = props[k];
                             break;
                          }
                       }
                       if(uvProp.IsValid())
                          break;
                    }

                    if(uvProp.IsValid())
                    {
                       // check if this alembic file has a uv options property
                       bool hasUvOptions = false;
                       if(abcMesh.valid())
                          hasUvOptions = abcMesh.getSchema().getPropertyHeader( ".uvOptions" ) != NULL;
                       else
                          hasUvOptions = abcSubD.getSchema().getPropertyHeader( ".uvOptions" ) != NULL;
                       if(hasUvOptions)
                       {
                          Abc::IFloatArrayProperty prop;
                          if(abcMesh.valid())
                             prop = Abc::IFloatArrayProperty( abcMesh.getSchema(), ".uvOptions" );
                          else
                             prop = Abc::IFloatArrayProperty( abcSubD.getSchema(), ".uvOptions" );

                          // if the prop stores any data
                          if(prop.getNumSamples() > 0)
                          {
                             Abc::FloatArraySamplePtr ptr = prop.getValue(0);
                             if(ptr->size() > 2 * uvI + 1)
                             {
                                bool uWrap = ptr->get()[uvI * 2 + 0] != 0.0f;
                                bool vWrap = ptr->get()[uvI * 2 + 1] != 0.0f;

                                CRefArray children = uvProp.GetNestedObjects();
                                for(LONG i=0; i<children.GetCount(); i++)
                                {
                                   ProjectItem child(children.GetItem(i));
                                   CString type = child.GetType();
                                   if(type == L"uvprojdef")
                                   {
                                      child.GetParameter(L"wrap_u").PutValue(uWrap);
                                      child.GetParameter(L"wrap_v").PutValue(vWrap);
                                      break;
                                   }
                                }
                             }
                          }
                       }

                       // we found it, and we need to attach the op
                       CustomOperator op;
                       if(attachToExisting)
                       {
                          CRef opRef;
                          opRef.Set(uvProp.GetFullName()+L".alembic_uvs");
                          op = opRef;
                       }
                       if(!op.IsValid() && bEnableOperatorCreation)
                       {
                          op = Application().GetFactory().CreateObject(L"alembic_uvs");
                          op.AddOutputPort(uvProp.GetRef());
                          op.AddInputPort(uvProp.GetRef());
                          op.AddInputPort(realTarget);
                          op.Connect();
                       }

                       if(op.IsValid())
                       {
                          op.PutParameterValue(L"path",file);
                          op.PutParameterValue(L"identifier",identifier+CString(L":")+CString(uvI));
                          if(bMultifile){
                              op.PutParameterValue(L"multifile", true);
                          }

                          if(meshUVsParam.getNumSamples() > 1)
                          {
                             CValue setExprReturn;
                             CValueArray setExprArgs(2);
                             setExprArgs[0] = op.GetFullName()+L".time";
                             setExprArgs[1] = getTimeControlExpression(timeControlProp.GetFullName());
                             Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
                          }
                       }
                     }
                  }
               }
            }
         }

         break;
      }
      case alembicItemType_curves:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_curves");
		// let's setup the ICE tree to load it
         ICETree iceTree;
         CValueArray treeArgs(2);
         CValue treeReturnVal;
         if(attachToExisting)
         {
            CRef treeRef;
            treeRef.Set(realTarget.GetAsText()+L".ABC_Load_Curves");
            iceTree = treeRef;
         }
         if(!iceTree.IsValid())
         {
            treeArgs[0] = L"ABC Load Curves";
            treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
            Application().ExecuteCommand(L"ApplyICEOp",treeArgs,treeReturnVal);
            iceTree = (CRef)treeReturnVal;
         }
         ICECompoundNode node = iceTree.GetCompoundNodes()[0];
         treeArgs[0] = node.GetFullName()+L".path_string";
         treeArgs[1] = file;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         treeArgs[0] = node.GetFullName()+L".identifier_string";
         treeArgs[1] = identifier;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);

         if(bMultifile){
            treeArgs[0] = node.GetFullName()+L".multifile";
            treeArgs[1] = true;
            Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         }

         if(isAnimated)
         {
            // check if we have a timecontrol in the args
            CRef timeControlRef;
            if(args.GetCount() > 0)
               timeControlRef = args[0];
            CustomProperty timeControlProp = timeControlRef;
            if(timeControlProp.IsValid())
            {
               treeArgs[0] = node.GetFullName()+L".TimeControl";
               treeArgs[1] = timeControlProp.GetFullName();
               Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
            }
         }

         // store the return value
         returnVal = iceTree.GetRef();
         break;
      }
      case alembicItemType_points:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_points");
				// let's setup the ICE tree to load it
         
         CValueArray treeArgs(2);
         CValue treeReturnVal;

         // we need to check if we have instances....
         AbcG::IPoints abcPoints(abcObject,Abc::kWrapExisting);
         if(!abcPoints.valid())
            return CStatus::OK;

		   Abc::IStringArrayProperty shapeInstanceNamesProp;
         if ( getArbGeomParamPropertyAlembic(abcPoints, "instancenames", shapeInstanceNamesProp) )
         {
            if(shapeInstanceNamesProp.getNumSamples() > 0)
            {
               Abc::StringArraySamplePtr shapeInstanceNamesPtr = shapeInstanceNamesProp.getValue(shapeInstanceNamesProp.getNumSamples()-1);
               if(shapeInstanceNamesPtr->size() > 0)
               {
                  ICETree iceTree;
                  if(attachToExisting)
                  {
                     CRef treeRef;
                     treeRef.Set(realTarget.GetAsText()+L".ABC_Instance_Shapes");
                     iceTree = treeRef;
                  }
                  if(!iceTree.IsValid())
                  {
                     treeArgs[0] = L"ABC Instance Shapes";
                     treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
                     Application().ExecuteCommand(L"ApplyICEOp",treeArgs,treeReturnVal);
                     iceTree = (CRef)treeReturnVal;
                  }

                  for(size_t j=0;j<shapeInstanceNamesPtr->size();j++)
                  {
                     std::string instanceIdentifier = shapeInstanceNamesPtr->get()[j];
                     //replace spaces with underscores
                     for(int c=0; c<instanceIdentifier.size(); c++){
                        if(instanceIdentifier[c] == ' '){
                           instanceIdentifier[c] = '_';
                        }
                     }

                     CString fullName = getFullNameFromIdentifier(importRootNode,instanceIdentifier);
                     treeArgs[0] = iceTree.GetFullName()+L".ABC_Instance_Shapes.Reference"+CString((LONG)j);
                     treeArgs[1] = fullName;
                     CStatus status = Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
                     if( status != CStatus::OK ) ESS_LOG_WARNING("Failed set ABC_Instance_Shapes.Reference");

                     // also check if we have this object in the scene
                     if(hasStandinSupport())
                     {
                        CRef ref;
                        ref.Set(fullName);
                        X3DObject x3d(ref);
                        if(x3d.IsValid())
                        {
                           // disable deferred loading on the instance sources
                           CRef standinPropRef;
                           standinPropRef.Set(fullName+L".arnold_standin");
                           Property prop(standinPropRef);
                           if(prop.IsValid())
                              prop.PutParameterValue(L"deferredLoading",false);

						         // enable hiding the instance masters
                           CRef visPropRef;
                           visPropRef.Set(fullName+L".visibility");
                           prop = Property(visPropRef);
                           if(prop.IsValid())
                              prop.PutParameterValue(L"hidemaster",true);
                        }
                     }
                  }
               }
            }
         }

         ICETree iceTree;
         if(attachToExisting)
         {
            CRef treeRef;
            treeRef.Set(realTarget.GetAsText()+L".ABC_Load_Points");
            iceTree = treeRef;
         }
         if(!iceTree.IsValid())
         {
            treeArgs[0] = L"ABC Load Points";
            treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
            CStatus status = Application().ExecuteCommand(L"ApplyICEOp",treeArgs,treeReturnVal);\
            if( status != CStatus::OK ) ESS_LOG_WARNING("Failed to ApplyICEOp ABC_Load_Points");
            iceTree = (CRef)treeReturnVal;
         }

         ICECompoundNode node = iceTree.GetCompoundNodes()[0];
         treeArgs[0] = node.GetFullName()+L".path_string";
         treeArgs[1] = file;
         CStatus status = Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         if( status != CStatus::OK ){
            ESS_LOG_WARNING("Failed set SetValue of path_string");
            ESS_LOG_WARNING("nodeFullName: "<<node.GetFullName().GetAsciiString());
         }

         treeArgs[0] = node.GetFullName()+L".identifier_string";
         treeArgs[1] = identifier;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);

         if(bMultifile){
            treeArgs[0] = node.GetFullName()+L".multifile";
            treeArgs[1] = true;
            Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         }

         if(isAnimated)
         {
            // check if we have a timeControl in the args
            CRef timeControlRef;
            if(args.GetCount() > 0)
               timeControlRef = args[0];
            CustomProperty timeControlProp = timeControlRef;
            if(timeControlProp.IsValid())
            {
               treeArgs[0] = node.GetFullName()+L".TimeControl";
               treeArgs[1] = timeControlProp.GetFullName();
               Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
            }
         }

         // store the return value
         returnVal = iceTree.GetRef();
         break;
      }
      case alembicItemType_metadata:
      {
			ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_metadata");
		Abc::ICompoundProperty abcCompound = getCompoundFromObject(abcObject);
         if ( abcCompound.getPropertyHeader( ".metadata" ) == NULL )
            break;

         Abc::IStringArrayProperty metaDataProp = Abc::IStringArrayProperty( abcCompound, ".metadata" );
         Abc::StringArraySamplePtr metaDataPtr = metaDataProp.getValue(0);
         if(metaDataPtr->size() != 20)
            break;

         // check if we already have the metadataprop
         CustomProperty xsiProp;
         CRefArray props = x3d.GetLocalProperties();
         for(LONG i=0;i<props.GetCount();i++)
         {
            CustomProperty prop(props[i]);
            if(!prop.IsValid())
               continue;
            if(!prop.GetType().IsEqualNoCase(L"alembic_metadata"))
               continue;
            xsiProp = prop;
            break;
         }
         if(!xsiProp.IsValid())
            xsiProp = x3d.AddProperty(L"alembic_metadata");

         // set all values
         size_t offset = 0;
         for(LONG i=0;i<10;i++)
         {
            xsiProp.PutParameterValue(L"name"+CString(i),CString(metaDataPtr->get()[offset++].c_str()));
            xsiProp.PutParameterValue(L"value"+CString(i),CString(metaDataPtr->get()[offset++].c_str()));
         }

         // store the return value
         returnVal = xsiProp.GetRef();
         break;
      }
      case alembicItemType_timecontrol:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_timecontrol");
		 CValueArray setExprArgs(2);
         CValue setExprReturn;
         CustomProperty timeControl = (CustomProperty) x3d.AddProperty(L"alembic_timecontrol");

         // prepare values for the setexpr command
         setExprArgs[0] = timeControl.GetFullName()+L".current";
         setExprArgs[1] = L"T";
         Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);

         // store the return value
         returnVal = timeControl.GetRef();
         break;
      }
      case alembicItemType_standin:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_standin");
		 // create an arnold property on the x3d if we don't have it yet!
         if(!hasStandinSupport())
         {
            Application().LogMessage(L"[ExocortexAlembic] There is no standin support. Please use a renderer supported standins.",siErrorMsg);
            return CStatus::InvalidArgument;
         }

         X3DObject sourceX3D = ProjectItem(realTarget).GetParent3DObject();
         CString projectItemName = ProjectItem(realTarget).GetFullName();
         CString sourceX3DFullName = sourceX3D.GetFullName();

         // let's see if we have the standin property already
         CustomProperty arnoldProp;
         CRef propRef;
         propRef.Set(sourceX3D.GetFullName()+L".arnold_standin");
         if(propRef.IsValid())
         {
            arnoldProp = CustomProperty(propRef);
         }
         else
         {
            arnoldProp = sourceX3D.AddProperty(L"arnold_standin",false);
         }

         // now check if the operator alrady exists
         CRef opRef;
         opRef.Set(arnoldProp.GetFullName()+L".alembic_standinop");
         if(!opRef.IsValid())
         {
            CustomOperator op = Application().GetFactory().CreateObject(L"alembic_standinop");
            op.AddOutputPort(arnoldProp.GetRef());
            op.AddInputPort(realTarget);
            op.Connect();

            // create the timecontrol expression
            // check if we have a timecontrol in the args
            CRef timeControlRef;
            if(args.GetCount() > 0)
               timeControlRef = args[0];
            Property timeControlProp = timeControlRef;
            if(timeControlProp.IsValid())
            {
               CValue setExprReturn;
               CValueArray setExprArgs(2);
               setExprArgs[0] = op.GetFullName()+L".time";
               setExprArgs[1] = getTimeControlExpression(timeControlProp.GetFullName());
               Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
            }
         }

         break;
      }
      default:
         break;
   }
   }

   return CStatus::OK;
}


CStatus alembic_create_item_Invoke
(
   const CString & type, 
   const CRef& importRootNode,
   const CRef & target,
   const CString & file,
   const CString & identifier,
   bool attachToExisting,
   const CValueArray & args
)
{
	CValue returnVal;
	alembic_create_item_Invoke( type,importRootNode, target, file, identifier, attachToExisting, args, returnVal );
	return CStatus::OK;
}

CStatus alembic_create_item_Invoke
(
   const CString & type, 
   const CRef& importRootNode,
   const CRef & target,
   const CString & file,
   const CString & identifier,
   bool attachToExisting
)
{
	CValueArray args(0);
	alembic_create_item_Invoke( type, importRootNode, target, file, identifier, attachToExisting, args );
	return CStatus::OK;
}




ESS_CALLBACK_START(alembic_create_item_Execute, CRef&)
	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");
   CString type = args[0];
   //CRef importRootNode = args[1];
   CRef target = args[1];
   CString file = args[2];
   CString identifier = args[3];
   bool reattach = args[4];
   CValueArray additionalArgs;
   for(LONG i=5;i<args.GetCount();i++)
      additionalArgs.Add(args[i]);
   CValue returnVal;
   CStatus result = alembic_create_item_Invoke(type,target,target,file,identifier,reattach,additionalArgs,returnVal);
   ctxt.PutAttribute(L"ReturnValue",returnVal);
   return result;
ESS_CALLBACK_END



CRef setupTimeControl(SceneNodeAlembicPtr fileXformNode, XSI::CRef importRootNode )
{
   {
      CString rootPath = importRootNode.GetAsText();
      rootPath += ".alembic_timecontrol";

      //ESS_LOG_WARNING("timeControl: "<<rootPath.GetAsciiString());

      // create the timecontrol
      CRef timeRef;
      timeRef.Set(rootPath);
      CustomProperty timeControl = timeRef;
      
      CValueArray setExprArgs(2);
      CValue setExprReturn;
      if(!timeControl.IsValid())
      {
         //ESS_LOG_WARNING("creating time control under "<<rootPath.GetAsciiString());

         X3DObject root(importRootNode);
         timeControl = root.AddProperty(L"alembic_timecontrol");

         // prepare values for the setexpr command
         setExprArgs[0] = timeControl.GetFullName()+L".current";
         setExprArgs[1] = L"T";
         Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
      }

      timeRef.Set(rootPath);

      if(!timeRef.IsValid()){
         ESS_LOG_ERROR("Could not find alembic_timecontrol");
      }

      return timeRef;
      // now update the args to use the timecontrol instead
      //setExprArgs[1] = timeControl.GetFullName()+L".current * "+timeControl.GetFullName()+L".factor + "+timeControl.GetFullName()+L".offset";
   }

   //CRef timeRef;
   //CString timeControlPath = importRootNode.GetAsText();
   //timeControlPath += ".alembic_timecontrol";
   //timeRef.Set(timeControlPath);
   ////CustomProperty timeControl = timeRef;
   //
   //if(!timeRef.IsValid()){
   //   ESS_LOG_ERROR("Could not find alembic_timecontrol");
   //   return false;
   //}

}

//the last parameter is ignored if attach to exising is active (since we are not creating a new node)
bool createNode(SceneNodeXSI* appNode, SceneNodeAlembicPtr fileNode, const IJobStringParser& jobParams, SceneNodePtr& returnNode, bool bAttachToExisting)
{  
    //the appNode parameter is either the parent if adding a new node to the scene, or the node to replace if doing attach to existing

   XSI::CRef importRootNode;
   {
      IJobStringParser& nonConstJobParams = (IJobStringParser&)jobParams;
      importRootNode.Set(nonConstJobParams.extraParameters["appRootPath"].c_str());
   }

   CString filename = CString(jobParams.filename.c_str());
   const bool& attachToExisting = bAttachToExisting;
   bool usePerModelTimeControls = jobParams.timeControl == timeControlOptions::ROOT_MODELS;
   //const bool& importStandins = jobParams.importStandinProperties;
   //const bool& importBboxes = jobParams.importBoundingBoxes;
   //const bool& failOnUnsupported = jobParams.failOnUnsupported;

   //CRef timeRef;
   //CString timeControlPath = importRootNode.GetAsText();
   //timeControlPath += ".alembic_timecontrol";
   //timeRef.Set(timeControlPath);

   //if(!timeRef.IsValid()){
   //   ESS_LOG_ERROR("Could not find alembic_timecontrol");
   //   return false;
   //}

   //CustomProperty timeControl = timeRef;
   CValueArray createItemArgs(8);
   //createItemArgs[0] = timeRef; //this is now intialized later on
   createItemArgs[1] = jobParams.importFacesets;
   createItemArgs[2] = jobParams.importNormals;
   createItemArgs[3] = jobParams.importUVs;
   createItemArgs[4] = jobParams.importVisibilityControllers;
   createItemArgs[5] = jobParams.useMultiFile;
   createItemArgs[6] = jobParams.operatorCreationForExistingNodes;
   createItemArgs[7] = jobParams.importTransformControllers;

   //the transform
   
   const Abc::IObject& iObj = fileNode->getObject();
   CString name = truncateName(fileNode->name.c_str());//iObj.getName().c_str());

   //if(jobParams.stripMayaNamespaces){
   //   name = stripNamespacePrefix(name);
   //}

   if(AbcG::IXform::matches(iObj.getMetaData()))
   {
      AbcG::IXform xform(iObj, Abc::kWrapExisting);
      XSI_XformTypes::xte xte = getXformType(xform);
      if( xte == XSI_XformTypes::UNKNOWN ){//if UNKNOWN, default chosen based on import option
         xte = jobParams.xformTypes; 
      }

      CRef nodeRef;
      if(attachToExisting){
	      ESS_PROFILE_SCOPE("attachToExisting");
         nodeRef = appNode->nodeRef;
        
         //if(!x3dobject.GetType().IsEqualNoCase(L"#model") && !x3dobject.GetType().IsEqualNoCase(L"null")){
         //   x3dobject.ResetObject();
         //}

         if(!nodeRef.IsValid()){
            ESS_LOG_ERROR("Could not attach xform "<<iObj.getFullName());
            return false;
         }

         returnNode = fileNode;

         fileNode->setAttached(true);
      }
      else{
         X3DObject parentX3DObject(appNode->nodeRef);

         if( xte == XSI_XformTypes::XMODEL ){
            ESS_PROFILE_SCOPE("creatNode Model");
            CRefArray objects;
            Model model;
            parentX3DObject.AddModel(objects, name, model);
            nodeRef = model.GetRef();
         }
         else{
            ESS_PROFILE_SCOPE("creatNode Null");
            Null null;
            parentX3DObject.AddNull(name, null);
            nodeRef = null.GetRef();
         }

         if(!nodeRef.IsValid()){
             ESS_LOG_ERROR("Could not create xform "<<iObj.getFullName());
             return false;
         }

         returnNode = SceneNodePtr(new SceneNodeXSI(nodeRef));
      }

      //keep track of the app node the alembic node maps to
      //needed from time control per model feature
      fileNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();

      if(usePerModelTimeControls){
         createItemArgs[0] = setupTimeControl(fileNode, findTimeControlDccIdentifier(fileNode, importRootNode, xte));
      }
      else{
         createItemArgs[0] = setupTimeControl(fileNode, importRootNode);
      }

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, iObj.getFullName().c_str(), attachToExisting, createItemArgs);

      // load xform
      alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, iObj.getFullName().c_str(), attachToExisting, createItemArgs);
      
      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef, filename, iObj.getFullName().c_str(), attachToExisting, createItemArgs);
      
   }
   else 
   {
		std::stringstream s;
		s << "Unsupported Alembic type: " << iObj.getFullName().c_str();
		if( jobParams.failOnUnsupported ) {
			ESS_LOG_ERROR( s.str().c_str() );
			return false;
		}
		ESS_LOG_WARNING( s.str().c_str() );
   }

   return true;
}

bool validate(CRef nodeRef, CString fileNodeType, Abc::IObject shapeObj )
{
   if(!nodeRef.IsValid()){
      ESS_LOG_ERROR("Could not attach "<<fileNodeType.GetAsciiString()<<" "<<shapeObj.getFullName());
      return false;
   }

   X3DObject x3dobject(nodeRef);
   CString type = x3dobject.GetType();
   if(!type.IsEqualNoCase(fileNodeType) && !type.IsEqualNoCase("null")){//allow all shape type to replace a null
      ESS_LOG_ERROR("Cannot attach "<<shapeObj.getFullName()<<" to a "<<type.GetAsciiString()<<" node.");
      return false;
   }

   if(type.IsEqualNoCase("null")){
      ESS_LOG_WARNING("Validate: Replacing null with shape "+shapeObj.getFullName());
      x3dobject.ResetObject();
   }

   return true;
}



bool createMergeableNode(SceneNodeXSI* appNode, SceneNodeAlembicPtr fileXformNode, SceneNodeAlembicPtr fileShapeNode, const IJobStringParser& jobParams, SceneNodePtr& returnNode, bool bAttachToExisting)
{
   //the appNode parameter is either the parent if adding a new node to the scene, or the node to replace if doing attach to existing

   XSI::CRef importRootNode;
   {
      IJobStringParser& nonConstJobParams = (IJobStringParser&)jobParams;
      importRootNode.Set(nonConstJobParams.extraParameters["appRootPath"].c_str());
   }


   bool usePerModelTimeControls = jobParams.timeControl == timeControlOptions::ROOT_MODELS;


   const CString filename(jobParams.filename.c_str());
   const bool& attachToExisting = bAttachToExisting;
   const bool& importStandins = jobParams.importStandinProperties;
   const bool& importBboxes = jobParams.importBoundingBoxes;
   const bool& failOnUnsupported = jobParams.failOnUnsupported;


   //CRef timeRef;
   //CString timeControlPath = importRootNode.GetAsText();
   //timeControlPath += ".alembic_timecontrol";
   //timeRef.Set(timeControlPath);
   ////CustomProperty timeControl = timeRef;
   //
   //if(!timeRef.IsValid()){
   //   ESS_LOG_ERROR("Could not find alembic_timecontrol");
   //   return false;
   //}

   // store the time control in a value array
   CValueArray createItemArgs(8);
   //createItemArgs[0] = timeRef;//this is now intialized later on
   createItemArgs[1] = jobParams.importFacesets;
   createItemArgs[2] = jobParams.importNormals;
   createItemArgs[3] = jobParams.importUVs;
   createItemArgs[4] = jobParams.importVisibilityControllers;
   createItemArgs[5] = jobParams.useMultiFile;
   createItemArgs[6] = jobParams.operatorCreationForExistingNodes;
   createItemArgs[7] = jobParams.importTransformControllers;


   Abc::IObject shapeObj = fileShapeNode->getObject();
   const char* shapeFullName = shapeObj.getFullName().c_str();
   const char* xformFullName = NULL;

   CString newAppNodeName;
   if(fileXformNode){
      //if we will merge will the shape node with its parent transform, we use the name of the transform node 
      //(not the shape). This is done to avoid namespace conflicts.
      xformFullName = fileXformNode->getObject().getFullName().c_str();
      newAppNodeName = truncateName(fileXformNode->name.c_str());//getObject().getName().c_str());

      fileXformNode->setMerged(true);
      fileShapeNode->setMerged(true);

      //ESS_LOG_WARNING("xformName: "<<xformFullName<<" - shapeName: "<<shapeFullName);
   }
   else{
      newAppNodeName = truncateName(fileShapeNode->name.c_str());//shapeObj.getName().c_str());

      //ESS_LOG_WARNING("shapeName: "<<shapeFullName);
   }
   //EC_LOG_INFO( "Object name: " << newAppNodeName.GetAsciiString() );

   //if(jobParams.stripMayaNamespaces){
    //  newAppNodeName = stripNamespacePrefix(newAppNodeName);
   //}
   
   if(AbcG::ICamera::matches(shapeObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import ICamera");
      // let's create a camera
      CRef nodeRef;
      Camera camera;
      if(attachToExisting)
      {
	      ESS_PROFILE_SCOPE("attachToExisting");
         nodeRef = appNode->nodeRef;

         if(!validate(nodeRef, CString("camera"), shapeObj)) return false;

         camera = nodeRef;

         returnNode = fileShapeNode;
         
         if(fileXformNode){
            fileXformNode->setAttached(true);
         }
         fileShapeNode->setAttached(true);
      }
      else 
      {
         X3DObject parentX3DObject(appNode->nodeRef);
         parentX3DObject.AddCamera(L"Camera", newAppNodeName, camera);
         nodeRef = camera.GetRef();

         if(!nodeRef.IsValid()){
            ESS_LOG_ERROR("Could not create camera "<<shapeObj.getFullName());
            return false;
         }

         returnNode = SceneNodePtr(new SceneNodeXSI(nodeRef));
      }

      if(fileXformNode){
         fileXformNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();
      }

      if(usePerModelTimeControls && fileXformNode){
         createItemArgs[0] = setupTimeControl(fileXformNode, findTimeControlDccIdentifier(fileXformNode, importRootNode, jobParams.xformTypes));
      }
      else{
         createItemArgs[0] = setupTimeControl(fileXformNode, importRootNode);
      }

      // delete the interest
      CValueArray deleteArgs(1);
      deleteArgs[0] = camera.GetInterest().GetFullName();
      CValue setExprReturn;
      Application().ExecuteCommand(L"DeleteObj",deleteArgs,setExprReturn);

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      // let's setup the xform op
      if(fileXformNode){
         alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, xformFullName, attachToExisting, createItemArgs);
      }
      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      // load camera
      alembic_create_item_Invoke(L"alembic_camera", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);
   }
   else if(AbcG::IPolyMesh::matches(shapeObj.getMetaData()) || AbcG::ISubD::matches(shapeObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import IPolyMesh");

      X3DObject meshObj;
      CRef nodeRef;
      if(attachToExisting)
      {
	     ESS_PROFILE_SCOPE("attachToExisting");
         nodeRef = appNode->nodeRef;

         if(!validate(nodeRef, CString("PolyMsh"), shapeObj)) return false;

         meshObj = nodeRef;

         returnNode = fileShapeNode;

         if(fileXformNode){
            fileXformNode->setAttached(true);
         }
         fileShapeNode->setAttached(true);
      }
      else
      {
         X3DObject parentX3DObject(appNode->nodeRef);
  
         XSI::CStatus status;
         if(importBboxes){
            status = parentX3DObject.AddGeometry(L"Cube", L"MeshSurface", newAppNodeName, meshObj);
         }
         else{
            ESS_PROFILE_SCOPE("createMergeableNode - AddPrimitive(EmptyPolygonMesh)");
		    CVector3Array verts(0);
		    CLongArray indices(0);
		    status = parentX3DObject.AddPolygonMesh( verts, indices, newAppNodeName, meshObj );
            //status = parentX3DObject..AddPrimitive(L"EmptyPolygonMesh", newAppNodeName, meshObj);//very slow, don't do this!
         }
         nodeRef = meshObj.GetRef();

         if(!nodeRef.IsValid()){
            ESS_LOG_ERROR("Could not create polymesh "<<shapeObj.getFullName());
         }

         returnNode = SceneNodePtr(new SceneNodeXSI(meshObj.GetRef()));
      }

      if(fileXformNode){
         fileXformNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();
      }

      if(usePerModelTimeControls && fileXformNode){
         createItemArgs[0] = setupTimeControl(fileXformNode, findTimeControlDccIdentifier(fileXformNode, importRootNode, jobParams.xformTypes));
      }
      else{
         createItemArgs[0] = setupTimeControl(fileXformNode, importRootNode);
      }

      // make the geometry approx local
      CValue makeLocalReturn;
      CValueArray makeLocalArgs(2);
      makeLocalArgs[0] = meshObj.GetFullName()+L".geomapprox";
      makeLocalArgs[1] = siNodePropagation;
      Application().ExecuteCommand(L"MakeLocal",makeLocalArgs,makeLocalReturn);

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      // create the topo op
      CRef returnOpRef;
      if(!importBboxes && !fileShapeNode->pObjCache->isMeshPointCache)
      {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_polymesh_topo", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }

      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      bool bLoadGeoApprox = false;
   
      if(!importBboxes){
         if(AbcG::ISubD::matches(shapeObj.getMetaData())){
            bLoadGeoApprox = true;
         }
         else{
	         AbcG::IPolyMesh abcMesh = AbcG::IPolyMesh(shapeObj, Abc::kWrapExisting);
            bLoadGeoApprox = abcMesh.getSchema().getPropertyHeader( ".faceVaryingInterpolateBoundary" ) != NULL;
         }
      }
      if(bLoadGeoApprox && jobParams.enableSubD){
		   alembic_create_item_Invoke(L"alembic_geomapprox", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);
      }

	   // let's setup the xform op
      if(fileXformNode){
         alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, xformFullName, attachToExisting, createItemArgs);
      }

      // let's setup the positions op
      if(importBboxes)
      {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_bbox", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }
      else
      {
         //TODO: what is check for? what should be done in the case of SUBD
         // only add the point position operator if we don't have dynamic topology
        bool receivesExpression = fileShapeNode->pObjCache->isMeshTopoDynamic;
         
         if(!receivesExpression)
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_polymesh", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }
      }

      // load standin property
      if(importStandins && returnOpRef.IsValid()){
         alembic_create_item_Invoke(L"alembic_standin", importRootNode, returnOpRef, filename, shapeFullName, attachToExisting, createItemArgs);
      }
   }

   else if(AbcG::INuPatch::matches(shapeObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import INuPatch");
      CRef nodeRef;
      X3DObject nurbsObj;
      if(attachToExisting)
      {
	     ESS_PROFILE_SCOPE("attachToExisting");
         nodeRef = appNode->nodeRef;

         if(!validate(nodeRef, CString("surfmsh"), shapeObj)) return false;
         nurbsObj = nodeRef;

         returnNode = fileShapeNode;

         if(fileXformNode){
            fileXformNode->setAttached(true);
         }
         fileShapeNode->setAttached(true);
      }

      if(fileXformNode){
         fileXformNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();
      }

      if(usePerModelTimeControls && fileXformNode){
         createItemArgs[0] = setupTimeControl(fileXformNode, findTimeControlDccIdentifier(fileXformNode, importRootNode, jobParams.xformTypes));
      }
      else{
         createItemArgs[0] = setupTimeControl(fileXformNode, importRootNode);
      }

      if(!nurbsObj.IsValid())
      {
         if( failOnUnsupported ) {
            ESS_LOG_ERROR( "Can't create new Nurb surfaces, can only attach.  Unsupported Alembic type: " << shapeObj.getFullName().c_str(); );
            return false;
         }
         ESS_LOG_WARNING( "Can't create new Nurb surfaces, can only attach.  Unsupported Alembic type: " << shapeObj.getFullName().c_str(); );
         return true;
	   }

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      // let's setup the xform op
      if(fileXformNode){
         alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, xformFullName, attachToExisting, createItemArgs);
      }

      alembic_create_item_Invoke(L"alembic_nurbs", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);
   }
   else if(AbcG::ICurves::matches(shapeObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import ICurves");
      // let's create a crvlist
      AbcG::ICurves curveIObject(shapeObj,Abc::kWrapExisting);
      AbcG::ICurvesSchema curveSchema = curveIObject.getSchema();
      AbcG::ICurvesSchema::Sample curveSample = curveSchema.getValue();

      // check for valid curve types...!
      if(curveSample.getType() != AbcG::kLinear &&
         curveSample.getType() != AbcG::kCubic)
      {
         std::stringstream s;
         s << "Can't create non-linear/non-cubic Curves.  Unsupported Alembic type: " << shapeObj.getFullName().c_str();
         if( failOnUnsupported ) {
            ESS_LOG_ERROR( s.str().c_str() );
            return false;
         }
         //ESS_LOG_WARNING( s.str().c_str() );
	   }

      // now let's check if we are looking at a curves node with color and radii

      bool useParticles = false;
      {
         Abc::IFloatArrayProperty propRadius;
         if( getArbGeomParamPropertyAlembic( curveIObject, "radius", propRadius ) ) {
            useParticles = true;
         }
         Abc::IC4fArrayProperty propColor;
         if( getArbGeomParamPropertyAlembic( curveIObject, "color", propColor ) ) {
            useParticles = true;
         } 
         if(jobParams.importCurvesAsStrands){
            useParticles = true;
         }
      }

      /*bool useParticles = curveSchema.getPropertyHeader( ".radius" ) != NULL || curveSchema.getPropertyHeader( ".color" ) != NULL;
      if(useParticles)
      {
         if( curveSchema.getPropertyHeader( ".radius" ) != NULL )
         {
            Abc::IFloatArrayProperty prop = Abc::IFloatArrayProperty( curveSchema, ".radius" );
            if(!prop.valid())
               useParticles = false;
            else if(prop.getNumSamples() == 0)
               useParticles = false;
         }
         else if( curveSchema.getPropertyHeader( ".color" ) != NULL )
         {
            Abc::IC4fArrayProperty prop = Abc::IC4fArrayProperty( curveSchema, ".color" );
            if(!prop.valid())
               useParticles = false;
            else if(prop.getNumSamples() == 0)
               useParticles = false;
         }
      }*/

      if (useParticles)
      {
         
         CRef nodeRef;        
         if(attachToExisting)
         {
 		      ESS_PROFILE_SCOPE("attachToExisting");
            nodeRef = appNode->nodeRef;

            if(!validate(nodeRef, CString("pointcloud"), shapeObj)) return false;

            returnNode = fileShapeNode;

            if(fileXformNode){
               fileXformNode->setAttached(true);
            }
            fileShapeNode->setAttached(true);
         }
         else
         {
            X3DObject parentX3DObject(appNode->nodeRef);
            X3DObject pointsObj;
            if(importBboxes){
               parentX3DObject.AddGeometry(L"Cube", L"MeshSurface", newAppNodeName, pointsObj);
            }
            else{
               parentX3DObject.AddPrimitive(L"PointCloud", newAppNodeName, pointsObj);
            }
            nodeRef = pointsObj.GetRef();
               
            if(!nodeRef.IsValid()){
               ESS_LOG_ERROR("Could not create curve "<<shapeObj.getFullName());
            }
            returnNode = SceneNodePtr(new SceneNodeXSI(nodeRef));
         }

         if(fileXformNode){
            fileXformNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();
         }

         if(usePerModelTimeControls && fileXformNode){
            createItemArgs[0] = setupTimeControl(fileXformNode, findTimeControlDccIdentifier(fileXformNode, importRootNode, jobParams.xformTypes));
         }
         else{
            createItemArgs[0] = setupTimeControl(fileXformNode, importRootNode);
         }

         // load metadata
         alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

         // load visibility
         alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

         // load curves
         CRef returnOpRef;
         if(importBboxes)
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_bbox", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }
         else
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_curves", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }

         // let's setup the xform op
         if(fileXformNode){
            alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, xformFullName, attachToExisting, createItemArgs);
         }

         // load standin property
         if(importStandins && returnOpRef.IsValid()){
            alembic_create_item_Invoke(L"alembic_standin", importRootNode, returnOpRef, filename, shapeFullName, attachToExisting, createItemArgs);
         }
      }
      else
      {
         X3DObject curveObj;
         CRef nodeRef;
         if(attachToExisting)
         {
            ESS_PROFILE_SCOPE("attachToExisting");
            nodeRef = appNode->nodeRef;
            
            if(!nodeRef.IsValid()){
               ESS_LOG_ERROR("Could not attach curve "<<shapeObj.getFullName());
            }
 
            X3DObject x3dobject(nodeRef);
            CString type = x3dobject.GetType();
            if(!x3dobject.GetType().IsEqualNoCase(L"crvlist") && !x3dobject.GetType().IsEqualNoCase(L"hair") && !type.IsEqualNoCase("null")){
               ESS_LOG_ERROR("Cannot attach "<<shapeObj.getFullName()<<" to a "<<type.GetAsciiString()<<" node.");
               return false;
            }

            if(type.IsEqualNoCase("null")){
               ESS_LOG_WARNING("Replacing null with shape "+shapeObj.getFullName());
               x3dobject.ResetObject();
            }

            curveObj = nodeRef;

            returnNode = fileShapeNode;

            if(fileXformNode){
               fileXformNode->setAttached(true);
            }
            fileShapeNode->setAttached(true);
         }
         else
         {
            X3DObject parentX3DObject(appNode->nodeRef);
            if(importBboxes){
               parentX3DObject.AddGeometry(L"Cube", L"MeshSurface", newAppNodeName, curveObj);
            }
            else{
               parentX3DObject.AddNurbsCurveList(CNurbsCurveDataArray(), siSINurbs, newAppNodeName, curveObj);
            }
            nodeRef = curveObj.GetRef();

            if(!nodeRef.IsValid()){
               ESS_LOG_ERROR("Could not create curve "<<shapeObj.getFullName());
            }

            returnNode = SceneNodePtr(new SceneNodeXSI(nodeRef));
         }
         
         if(fileXformNode){
            fileXformNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();
         }

         if(usePerModelTimeControls && fileXformNode){
            createItemArgs[0] = setupTimeControl(fileXformNode, findTimeControlDccIdentifier(fileXformNode, importRootNode, jobParams.xformTypes));
         }
         else{
            createItemArgs[0] = setupTimeControl(fileXformNode, importRootNode);
         }

         // load metadata
         alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

         // load visibility
         alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

         // load curve topo if it's not hair because that will already have desired topology if it exists
         if(!importBboxes && !curveObj.GetType().IsEqualNoCase(L"hair")){
            alembic_create_item_Invoke(L"alembic_crvlist_topo", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);
         }



         // allow stretching as there may have been dynamics applied to the hair
         if( curveObj.GetType().IsEqualNoCase(L"hair")){
            curveObj.GetActivePrimitive().PutParameterValue(L"AllowStretch", true);
         }

         // let's setup the xform op
         if(fileXformNode){
            alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, xformFullName, attachToExisting, createItemArgs);
         }

         // load curve anim
         CRef returnOpRef;
         if(importBboxes){
         CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_bbox", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }
         else{
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_crvlist", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }

         // load standin property
         if(importStandins && returnOpRef.IsValid()){
            alembic_create_item_Invoke(L"alembic_standin", importRootNode, returnOpRef, filename, shapeFullName, attachToExisting, createItemArgs);
         }
      }

   }
   else if(AbcG::IPoints::matches(shapeObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import IPoints");
      AbcG::IPoints pointsIObject(shapeObj,Abc::kWrapExisting);
      AbcG::IPointsSchema pointsSchema = pointsIObject.getSchema();
      AbcG::IPointsSchema::Sample pointsSample = pointsSchema.getValue();

      CRef nodeRef;
      if(attachToExisting)
      {
         ESS_PROFILE_SCOPE("attachToExisting");
         nodeRef = appNode->nodeRef;

         if(!validate(nodeRef, CString("pointcloud"), shapeObj)) return false;

         returnNode = fileShapeNode;

         if(fileXformNode){
            fileXformNode->setAttached(true);
         }
         fileShapeNode->setAttached(true);
      }
      else
      {
         X3DObject parentX3DObject(appNode->nodeRef);
         X3DObject pointsObj;
         if(importBboxes){
            parentX3DObject.AddGeometry(L"Cube", L"MeshSurface", newAppNodeName, pointsObj);
         }
         else{
            parentX3DObject.AddPrimitive(L"PointCloud", newAppNodeName, pointsObj);
         }
         nodeRef = pointsObj.GetRef();

         if(!nodeRef.IsValid()){
            ESS_LOG_ERROR("Could not create points "<<shapeObj.getFullName());
         }

         returnNode = SceneNodePtr(new SceneNodeXSI(nodeRef));
      }

      if(fileXformNode){
         fileXformNode->dccIdentifier = nodeRef.GetAsText().GetAsciiString();
      }

      if(usePerModelTimeControls && fileXformNode){
         createItemArgs[0] = setupTimeControl(fileXformNode, findTimeControlDccIdentifier(fileXformNode, importRootNode, jobParams.xformTypes));
      }
      else{
         createItemArgs[0] = setupTimeControl(fileXformNode, importRootNode);
      }

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      // let's setup the xform op
      if(fileXformNode){
         alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, xformFullName, attachToExisting, createItemArgs);
      }

      // apply the ice tree
      CRef returnOpRef;
      if(importBboxes) {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_bbox", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      } else {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_points", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }

      // load standin property
      if(importStandins && returnOpRef.IsValid()){
         alembic_create_item_Invoke(L"alembic_standin", importRootNode, returnOpRef, filename, shapeFullName, attachToExisting, createItemArgs);
      }
   }
   else { 
		std::stringstream s;
		s << "Unsupported Alembic type: " << shapeObj.getFullName().c_str();
		if( failOnUnsupported ) {
			ESS_LOG_ERROR( s.str().c_str() );
			return false;
		}
		ESS_LOG_WARNING( s.str().c_str() );
   }

   return true;
}


bool createNodes(SceneNodeXSI* const appNode, SceneNodeAlembicPtr fileNode, const IJobStringParser& jobParams, SceneNodePtr& returnNode, bool bAttachToExisting)
{

   if( fileNode->type == SceneNode::ETRANSFORM ){//we have a transform with only one shape node child, so we can merge

      SceneNodeAlembicPtr shapeNode;
      for(SceneChildIterator it = fileNode->children.begin(); it != fileNode->children.end(); it++){
         if( isShapeNode((*it)->type)){
            shapeNode = reinterpret<SceneNode, SceneNodeAlembic>(*it);
            break;
         }
      }
      if(shapeNode){
            return createMergeableNode(appNode, fileNode, shapeNode, jobParams, returnNode, bAttachToExisting);
      }
      else{
         ESS_LOG_ERROR("Could not find shape node.");
         return false;
      }
   }
   else if( fileNode->type == SceneNode::ITRANSFORM ){// null nodes
      return createNode(appNode, fileNode, jobParams, returnNode, bAttachToExisting);
   }
   //this shape node has the same parent transform as one or more other shape nodes
   SceneNodeAlembicPtr xformNode;
   return createMergeableNode(appNode, xformNode, fileNode, jobParams, returnNode, bAttachToExisting);
}


struct ImportStackElement
{
   SceneNodePtr sceneNode;
   CRef parentNode;

   ImportStackElement(SceneNodePtr node):sceneNode(node)
   {}
   ImportStackElement(SceneNodePtr node, CRef parent):sceneNode(node), parentNode(parent)
   {}

};

ESS_CALLBACK_START(alembic_import_Execute, CRef&)

	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");

   // inspect it
   CValueArray importJobArgs(1);
   CValue importJobResult;

   //CString filename = args[0];
   //bool importNormals = (bool)args[1];
   //bool importUVs = (bool)args[2];
   //bool importClusters = (bool)args[3];
   //bool importVisibility = (bool)args[4];
   //bool importStandins = (bool)args[5];
   //bool importBboxes = (bool)args[6];
   //bool attachToExisting = (bool)args[7];
   //bool failOnUnsupported = (bool)args[8];
   //CString identifierListStr = args[9].GetAsText();

   std::stringstream sstream;

   if( args.GetCount() != 10 ) {
     ESS_LOG_ERROR("The alembic_import command requires 10 arguments, encountered only " << args.GetCount() << " arguments." );
     return CStatus( CStatus::InvalidArgument );
   }

   if(!args[0].GetAsText().IsEmpty()){
      sstream<<"filename="<<args[0].GetAsText().GetAsciiString()<<";";
   }
   sstream<<"normals="<<(LONG)args[1]<<";uvs="<<(LONG)args[2]<<";facesets="<<(LONG)args[3]<<";importVisibilityControllers="<<(LONG)args[4];
   sstream<<";importStandinProperties="<<(LONG)args[5]<<";importBoundingBoxes="<<(LONG)args[6]<<";attachToExisting="<<(LONG)args[7];
   sstream<<";failOnUnsupported="<<(LONG)args[8];
   if(!args[9].GetAsText().IsEmpty()){
      sstream<<";identifiers=";
      sstream<<args[9].GetAsText().GetAsciiString();
   }

   ESS_LOG_WARNING("The alembic_import command is deprecated. Please use alembic_import_jobs instead.");

   importJobArgs[0] = CString(sstream.str().c_str());
   return Application().ExecuteCommand(L"alembic_import_jobs", importJobArgs, importJobResult);

ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_import_jobs_Execute, CRef&)
	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");
	

   IJobStringParser jobParser;
   std::string jobString = args[0].GetAsText().GetAsciiString();

   if(jobString.empty()){

      // let's setup the property
      CustomProperty settings;
      settings = Application().GetActiveSceneRoot().AddProperty(L"alembic_import_settings");

      // inspect it
      CValueArray inspectArgs(5);
      CValue inspectResult;
      inspectArgs[0] = settings.GetFullName();
      inspectArgs[1] = L"";
      inspectArgs[2] = L"Import Settings";
      inspectArgs[3] = siModal;
      inspectArgs[4] = false;
      Application().ExecuteCommand(L"InspectObj",inspectArgs,inspectResult);
      
      // prepare for deletion
      inspectArgs.Resize(1);
      inspectArgs[0] = settings.GetFullName();
      if((bool)inspectResult) 
      {
         Application().ExecuteCommand(L"DeleteObj",inspectArgs,inspectResult);
         return CStatus::Abort;
      }

      // retrieve the options
      jobParser.importNormals = settings.GetParameterValue(L"normals");
      jobParser.importUVs = settings.GetParameterValue(L"uvs");
      jobParser.importFacesets = settings.GetParameterValue(L"facesets");
      jobParser.importVisibilityControllers = (bool)settings.GetParameterValue(L"visibility");
	  jobParser.importTransformControllers = (bool)settings.GetParameterValue(L"transforms");
      if(hasStandinSupport())
      {
         LONG standinsValue = settings.GetParameterValue(L"standins");
         jobParser.importStandinProperties = standinsValue > 0;
         jobParser.importBoundingBoxes = standinsValue == 2;
      }
      else
      {
         jobParser.importStandinProperties = false;
         jobParser.importStandinProperties = false;
      }
      //jobParser.attachToExisting = settings.GetParameterValue(L"attach");
	  jobParser.failOnUnsupported = settings.GetParameterValue(L"failOnUnsupported");
      jobParser.skipUnattachedNodes = settings.GetParameterValue(L"skipUnattachedNodes");
      jobParser.replacer = SearchReplace::createReplacer();
      jobParser.enableImportRootSelection = settings.GetParameterValue(L"enableImportRootSelection");
      jobParser.stripMayaNamespaces = settings.GetParameterValue(L"stripNamespaces");
      jobParser.importCurvesAsStrands = settings.GetParameterValue(L"importCurvesAsStrands");
      jobParser.useMultiFile = settings.GetParameterValue(L"multifile");
      jobParser.enableSubD = settings.GetParameterValue(L"enableSubD");
      jobParser.operatorCreationForExistingNodes = settings.GetParameterValue(L"operatorCreationForExistingNodes");
      
      int val = settings.GetParameterValue(L"defaultXformNode");
      if( val == 0 ){
         jobParser.xformTypes = XSI_XformTypes::XMODEL;
      }
      else if( val == 1){
         jobParser.xformTypes = XSI_XformTypes::XNULL;
      }

      val = settings.GetParameterValue(L"sceneMergeMethod");
      if( val == 0 ){
         jobParser.extraParameters["sceneMergeMethod"] = "new";
      }
      else if( val == 1){
         jobParser.extraParameters["sceneMergeMethod"] = "attach";
      }
      else if( val == 2){
         jobParser.extraParameters["sceneMergeMethod"] = "attachAndNew";
      }

      val = settings.GetParameterValue(L"timeControlPlacement");
      if( val == 0 ){
         jobParser.timeControl = timeControlOptions::SCENE_ROOT;
      }
      else if( val == 1){
         jobParser.timeControl = timeControlOptions::ROOT_MODELS;
      }

      if(settings.GetParameterValue(L"fitTimeRange")){
         jobParser.setParam("fitTimeRange"); 
      }

      std::stringstream versionInfo;
      versionInfo<<"Exocortex Crate "<<PLUGIN_MAJOR_VERSION<<"."<<PLUGIN_MINOR_VERSION<<"."<<crate_BUILD_VERSION;
      Application().LogMessage(versionInfo.str().c_str());
      Application().LogMessage(CString(L"[ExocortexAlembic] Using ReadJob:") + jobParser.buildJobString().c_str());

      Application().ExecuteCommand(L"DeleteObj",inspectArgs,inspectResult);
   }
   else{
      bool bParseSuccess = jobParser.parse(jobString);
      if(!bParseSuccess){
         ESS_LOG_ERROR("[alembic] Error parsing import job string.");
         return CStatus::Abort;
      }
      Application().LogMessage(CString(L"[ExocortexAlembic] Using ReadJob:") + jobString.c_str());

      if( jobParser.extraParameters["sceneMergeMethod"] == "new" && jobParser.attachToExisting ){//backwards compatibility with "attachToExisting" bool
         jobParser.extraParameters["sceneMergeMethod"] = "attach";
      }
   }

   // take care of the filename
   if(jobParser.filename.empty())
   {
	  // let's see if we are in interactive mode
      if(Application().IsInteractive())
      {
         CComAPIHandler toolkit;
         toolkit.CreateInstance(L"XSI.UIToolkit");
         CComAPIHandler filebrowser(toolkit.GetProperty(L"FileBrowser"));
         filebrowser.PutProperty(L"InitialDirectory",Application().GetActiveProject().GetPath());
         filebrowser.PutProperty(L"Filter",L"Alembic Files(*.abc)|*.abc||");
         CValue returnVal;
         filebrowser.Call(L"ShowOpen",returnVal);
         jobParser.filename = filebrowser.GetProperty(L"FilePathName").GetAsText().GetAsciiString();
         if(jobParser.filename.empty()){
            return CStatus::Abort;
         } 
      }
      else
      {
         Application().LogMessage(L"[ExocortexAlembic] No filename specified.",siErrorMsg);
         return CStatus::InvalidArgument;
      }
   }

   {
   ESS_PROFILE_SCOPE("alembic_import_jobs_Execute - without UI Dialog");

   // let's try to read this
   Abc::IArchive* archive = NULL;
   try{
      archive = getArchiveFromID( jobParser.filename );
   }
   catch(Alembic::Util::Exception& e){
      std::string exc(e.what());
      ESS_LOG_ERROR("[alembic] Error reading file: "<<e.what());
      return CStatus::Fail;
   }
   catch(...){
     ESS_LOG_ERROR("[alembic] Error reading file: "<<jobParser.filename << " (uncaught exception)");
      return CStatus::Fail;
   }
   if( archive == NULL ) {
      ESS_LOG_ERROR("[alembic] Error reading file: "<<jobParser.filename<< " (NULL alembic pointer)");
      return CStatus::Fail;
   }

   addRefArchive( jobParser.filename );
   AbcArchiveCache *pArchiveCache = getArchiveCache( jobParser.filename );

   CString filenameCStr(jobParser.filename.c_str());

   // also precap the jobParser.filename with the project token just in case
   CString projectPath = Application().GetActiveProject().GetPath();
   for(ULONG i=0;i<filenameCStr.Length();i++)
   {
      if(filenameCStr.GetAt(i) == '\\')
         filenameCStr = filenameCStr.GetSubString(0,i)+L"/"+filenameCStr.GetSubString(i+1,10000);
   }
   for(ULONG i=0;i<projectPath.Length();i++)
   {
      if(projectPath.GetAt(i) == '\\')
         projectPath = projectPath.GetSubString(0,i)+L"/"+projectPath.GetSubString(i+1,10000);
   }
   if(filenameCStr.GetSubString(0,projectPath.Length()) == projectPath)
   {
      filenameCStr = L"[project path]"+filenameCStr.GetSubString(projectPath.Length(),10000);
   }



   CRef importRootNode = Application().GetActiveSceneRoot().GetRef();
   
   if(jobParser.extraParameters.find("importRoot") != jobParser.extraParameters.end())
   {
      CRef rootNode;
      rootNode.Set(jobParser.extraParameters["importRoot"].c_str());
      if(rootNode.IsValid()){
         importRootNode = rootNode;
      }
      else{
         ESS_LOG_WARNING("importRoot is not valid. Using Scene_Root instead.");
      }
   }
   else if(jobParser.enableImportRootSelection)
   {
      CRefArray selectedObjects = Application().GetSelection().GetArray();
      if(selectedObjects.GetCount() > 1)
      {
         Application().LogMessage(L"[ExocortexAlembic] Too many objects selected, you can select at most one import root.", siErrorMsg);
         return CStatus::InvalidArgument;
      }
         
      if(selectedObjects.GetCount() == 1)
      {
         importRootNode = selectedObjects[0];
         //importRootNode = X3DObject( importRootNode ).GetParent3DObject().GetRef();
         importRootNode = X3DObject( importRootNode ).GetRef();
         ESS_LOG_WARNING("Attachment root is "<<importRootNode.GetAsText().GetAsciiString());
      }
   }
   jobParser.extraParameters["appRootPath"] = importRootNode.GetAsText().GetAsciiString(); 


   AbcG::IObject root = archive->getTop();
 

   AbcObjectCache *pRootObjectCache = &( pArchiveCache->find( "/" )->second );

   jobParser.replaceColonsWithUnderscores = true;
   int nNumNodes = 0;
   SceneNodeAlembicPtr fileRoot = buildAlembicSceneGraph(pArchiveCache, pRootObjectCache, nNumNodes, jobParser, false);

   fileRoot->dccIdentifier = Application().GetActiveSceneRoot().GetRef().GetAsText().GetAsciiString();

   if(!jobParser.selectShapes){
      ESS_LOG_WARNING("Only selecting transform nodes (shape selection disabled)");
   }

   bool bImportAllNodes = true;

   if(jobParser.nodesToImport.size() > 0){

      std::map<std::string, bool> selectionMap;

      for(int i=0; i<jobParser.nodesToImport.size(); i++){
         selectionMap[jobParser.nodesToImport[i]] = true;
      }
      
      //Note: the ImportScene and AttachToScene methods assume that parents of each selected node are also selected
      int numSelected = selectNodes(fileRoot, selectionMap, true /*select parents*/, false /*select children*/, jobParser.selectShapes/*select shape nodes*/);

      if(numSelected < jobParser.nodesToImport.size()){
         ESS_LOG_WARNING("Unabled find all filter nodes specified.");
      }

      if(numSelected > 0){
         nNumNodes = numSelected;
         bImportAllNodes = false;
      }
   }
   else if(!jobParser.selectShapes){
      int numSelected = selectTransformNodes(fileRoot);
      if(numSelected > 0){
         nNumNodes = numSelected;
         bImportAllNodes = false;
      }
   }

   //ImportScene and AttachScene assume unselected nodes have been removed from the alembic file scene graph
   if(!bImportAllNodes){
      removeUnselectedNodes(fileRoot);
   }

   //printSceneGraph(fileRoot, false);

   //return CStatus::Fail;

   // clear the imported names!
   //nameMapClear();
   CString transformCacheModelName;
   Model transformCacheModel;

   // clear all alembic user data
   alembic_UD::clearAll();

   //return CStatus::Fail;

   if( jobParser.paramIsSet("fitTimeRange") ){

      size_t oMinSample=(size_t)-1, oMaxSample=0;
      double oMinTime = DBL_MIN, oMaxTime = -DBL_MAX;
      GetSampleRange(fileRoot, oMinSample, oMaxSample, oMinTime, oMaxTime);
      //ESS_LOG_WARNING("time range: "<<oMinTime<<" "<<oMaxTime);

      if(oMaxSample > 1){

         Application app;
         Project prj = app.GetActiveProject();

         // The PlayControl property set is stored with scene data under the project
         CRefArray proplist = prj.GetProperties();
         Property playctrl( proplist.GetItem(L"Play Control") );

         double fps = playctrl.GetParameterValue(L"Rate");

         //ESS_LOG_WARNING("fps: "<<fps);

         playctrl.PutParameterValue(L"Out", (LONG)ceil(oMaxTime * fps));

      }  
   }

   std::list<SceneNodeAppPtr> newNodes;

   if( jobParser.extraParameters["sceneMergeMethod"] == "attach" )//if(jobParser.attachToExisting)
   {  
      nNumNodes = 0;
      SceneNodeXSIPtr appRoot = buildCommonSceneGraph(importRootNode, nNumNodes, false, false);

      //printSceneGraph(fileRoot, true);
      //printSceneGraph(appRoot, true);
      
      XSIProgressBar progBar;
      progBar.init(nNumNodes);

      bool bAttachSuccess = AttachSceneFile(fileRoot, appRoot, jobParser, &progBar, &newNodes);

      if(!bAttachSuccess){
         return CStatus::Fail;
      }
   }
   else if( jobParser.extraParameters["sceneMergeMethod"] == "attachAndNew" ){
      nNumNodes = 0;
      SceneNodeXSIPtr appRoot = buildCommonSceneGraph(importRootNode, nNumNodes, false, false);

      //printSceneGraph(fileRoot, true);
      //printSceneGraph(appRoot, true);

      XSIProgressBar progBar;
      progBar.init(nNumNodes);

      bool bAttachSuccess = MergeSceneFile(fileRoot, appRoot, jobParser, &progBar, &newNodes);

      if(!bAttachSuccess){
         return CStatus::Fail;
      }
   }
   else
   {
      //should build a full scene graph when start doing name checking
      SceneNodeXSIPtr appRoot(new SceneNodeXSI(importRootNode));

      //printSceneGraph(fileRoot, false);

      XSIProgressBar progBar;
      progBar.init(nNumNodes);

      bool bImportSuccess = ImportSceneFile(fileRoot, appRoot, jobParser, &progBar, &newNodes);
      
      if(!bImportSuccess){
         return CStatus::Fail;
      }

   }


   CValueArray vals;
   for(std::list<SceneNodeAppPtr>::iterator it = newNodes.begin(); it != newNodes.end(); it++)
   {
      SceneNodeXSIPtr appNode = reinterpret<SceneNodeApp, SceneNodeXSI>(*it);

     // X3DObject xObj(appNode->nodeRef);

      ////ESS_LOG_WARNING("name: "<<fullname.GetAsciiString());
      ////CString fullname = xObj.GetFullName();

      //CString name = xObj.GetName();
      //CString modelname = xObj.GetModel().GetName();
      //vals.Add(modelname+"."+name);

      //vals.Add(xObj);

      vals.Add(appNode->nodeRef);
   }

   CValue returnVal(vals);
   ctxt.PutAttribute(L"ReturnValue", returnVal);


   delRefArchive( jobParser.filename );

   }

   return CStatus::OK;
ESS_CALLBACK_END


ESS_CALLBACK_START(alembic_import_settings_Define, CRef&)
	Context ctxt( in_ctxt );
	CustomProperty oCustomProperty;
	Parameter oParam;
	oCustomProperty = ctxt.GetSource();

   // get the current frame in an out
	oCustomProperty.AddParameter(L"normals",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"uvs",CValue::siBool,siPersistable,L"",L"",1,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"facesets",CValue::siBool,siPersistable,L"",L"",1,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"visibility",CValue::siInt4,siPersistable,L"",L"",0,0,10,0,10,oParam);
   oCustomProperty.AddParameter(L"transforms",CValue::siInt4,siPersistable,L"",L"",0,0,10,0,10,oParam);
   if(hasStandinSupport())
   {
      oCustomProperty.AddParameter(L"standins",CValue::siInt4,siPersistable,L"",L"",0,0,10,0,10,oParam);
   }
   //oCustomProperty.AddParameter(L"attach",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"sceneMergeMethod",CValue::siInt4,siPersistable,L"",L"",0,0,5,0,5,oParam);
   oCustomProperty.AddParameter(L"skipUnattachedNodes",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"failOnUnsupported",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"enableImportRootSelection",CValue::siBool,siPersistable,L"",L"",0,0,1,0,0,oParam);
   oCustomProperty.AddParameter(L"stripNamespaces",CValue::siBool,siPersistable,L"",L"",0,0,1,0,0,oParam);
   oCustomProperty.AddParameter(L"importCurvesAsStrands",CValue::siBool,siPersistable,L"",L"",0,0,1,0,0,oParam);
   oCustomProperty.AddParameter(L"fitTimeRange",CValue::siBool,siPersistable,L"",L"",0,0,1,0,0,oParam);
   oCustomProperty.AddParameter(L"multifile",CValue::siBool,siPersistable,L"",L"",0,0,1,0,0,oParam);
   oCustomProperty.AddParameter(L"enableSubD",CValue::siBool,siPersistable,L"",L"",1,0,1,0,0,oParam);
   oCustomProperty.AddParameter(L"defaultXformNode",CValue::siInt4,siPersistable,L"",L"",0,0,5,0,5,oParam);
   oCustomProperty.AddParameter(L"timeControlPlacement",CValue::siInt4,siPersistable,L"",L"",0,0,5,0,5,oParam);
   oCustomProperty.AddParameter(L"operatorCreationForExistingNodes",CValue::siBool,siPersistable,L"",L"",1,0,1,0,0,oParam);

	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_import_settings_DefineLayout, CRef&)
	Context ctxt( in_ctxt );
	PPGLayout oLayout;
	PPGItem oItem;
	oLayout = ctxt.GetSource();
	oLayout.Clear();

    oLayout.SetViewSize(600, 600);

    std::stringstream versionText;
   versionText<<"Exocortex Crate "<<PLUGIN_MAJOR_VERSION<<"."<<PLUGIN_MINOR_VERSION<<"."<<crate_BUILD_VERSION;
   oLayout.AddStaticText(versionText.str().c_str());

   oLayout.AddGroup(L"Geometry");
   oLayout.AddItem(L"normals",L"Normals");
   oLayout.AddItem(L"uvs",L"UVs");
   oLayout.AddItem(L"facesets",L"Clusters");

   CValueArray items(4);
   items[0] = L"Just Import Value if Constant";
   items[1] = (LONG) 0l;
   items[2] = L"Connected Operators";
   items[3] = (LONG) 1l;
   oLayout.AddEnumControl(L"visibility",items,L"Visibility");

   items.Resize(4);
   items[0] = L"Just Import Value if Constant";
   items[1] = (LONG) 0l;
   items[2] = L"Connected Operators";
   items[3] = (LONG) 1l;
   oLayout.AddEnumControl(L"transforms",items,L"Transforms");

   if(hasStandinSupport())
   {
      items.Resize(6);
      items[0] = L"No standins";
      items[1] = (LONG) 0l;
      items[2] = L"Import data + standins";
      items[3] = (LONG) 1l;
      items[4] = L"Standins as bboxes";
      items[5] = (LONG) 2l;
      oLayout.AddEnumControl(L"standins",items,L"Standins");
   }
   //oLayout.AddItem(L"attach", L"Attach to existing objects");

   items.Resize(6);
   items[0] = L"New nodes";
   items[1] = (LONG) 0l;
   items[2] = L"Attach to existing";
   items[3] = (LONG) 1l;
   items[4] = L"Attach to existing + new nodes";
   items[5] = (LONG) 2l;
   oLayout.AddEnumControl(L"sceneMergeMethod", items, L"Scene Merge Method");

   
   oLayout.AddItem(L"skipUnattachedNodes", L"Skip nodes that fail to attach");
   oLayout.AddItem(L"failOnUnsupported",L"Fail upon unsupported alembic types");
   oLayout.AddItem(L"enableImportRootSelection",L"Import Root Selection");
   oLayout.AddItem(L"stripNamespaces",L"Strip Namespaces");
   oLayout.AddItem(L"importCurvesAsStrands", L"Import Curves as Strands");
   oLayout.AddItem(L"fitTimeRange", L"Fit Time Range");
   oLayout.AddItem(L"multifile", L"Multifile");
   oLayout.AddItem(L"enableSubD", L"Subdivision Surfaces");
   oLayout.AddItem(L"operatorCreationForExistingNodes", L"Operator Creation For Existing Nodes");

   items.Resize(4);
   items[0] = L"Model";
   items[1] = (LONG) 0l;
   items[2] = L"Null";
   items[3] = (LONG) 1l;
   oLayout.AddEnumControl(L"defaultXformNode", items, L"Default Xform Node");

   items.Resize(4);
   items[0] = L"Scene Root";
   items[1] = (LONG) 0l;
   items[2] = L"Root Models";
   items[3] = (LONG) 1l;
   oLayout.AddEnumControl(L"timeControlPlacement", items, L"Time Control Placement");


   oLayout.EndGroup();

	return CStatus::OK;
ESS_CALLBACK_END
